[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! My name is Manuel and I am living in Switzerland. I have graduated in physics and currently I am working in IT. In this blog, I occasionally write about my hobby projects. Usually, you can expect to read about physics, electronics, math or computer science.\nThis website is built using the amazing Quarto publishing system. Its quarto source code can be found here."
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "In this post, I try to find and illustrate geodesics on 2-D curved surfaces that are embedded in 3-D space. Due to a specific question from a friend of mine, the main goal is to find closed geodesics on a Möbius strip.\nA geodesic is a curve in the surface with no transversal acceleration, i.e. a straight line. E.g. the shortest path between two points is a geodesic. Any path connecting the two points is a geodesic, if and only if a rope, which is aligned along this curve on the surface, does not change its shape under tension.\nWe follow the definitions and formalism in https://de.wikipedia.org/wiki/Christoffelsymbole. We assume to have a parametrization of the curved surface which embed them into 3-D euclidean space by the function \\[X:  (u,v) \\rightarrow (x,y,z) \\in \\mathbb R^3.\\]\nChristoffel symbols \\(\\Gamma^a_{bc}\\) can be calculated with the identities \\[\\begin{align}\n\\frac{\\partial^2 X}{\\partial u^2} &= \\Gamma^1_{11} \\frac{\\partial X}{\\partial u} + \\Gamma^2_{11}\\frac{\\partial X}{\\partial v} + h_{11} N\\,,\\\\[0.5em]\n\\frac{\\partial^2 X}{\\partial u \\partial v} &= \\Gamma^1_{12} \\frac{\\partial X}{\\partial u} + \\Gamma^2_{12}\\frac{\\partial X}{\\partial v} + h_{12} N\\,,\\\\[0.5em]\n\\frac{\\partial^2 X}{\\partial v \\partial u} &= \\Gamma^1_{21} \\frac{\\partial X}{\\partial u} + \\Gamma^2_{21}\\frac{\\partial X}{\\partial v} + h_{21} N\\,,\\\\[0.5em]\n\\frac{\\partial^2 X}{\\partial v^2} &= \\Gamma^1_{22} \\frac{\\partial X}{\\partial u} + \\Gamma^2_{22}\\frac{\\partial X}{\\partial v} + h_{22} N\\,.\n\\end{align}\\]\nGiven a curve \\(\\gamma(t) = X(u(t), v(t))\\) on the surface, and using the definition \\(u_1=u\\) and \\(u_2=v\\), the tangential (in-plane) acceleration can be writen as \\[(\\ddot\\gamma)^\\top = \\left(\\ddot u_1 + \\sum_{i,j = 1}^2 \\Gamma^1_{ij} \\dot u_i \\dot u_j \\right)\\frac{\\partial X}{\\partial u_1} + \\left(\\ddot u_2 + \\sum_{i,j=1}^2 \\Gamma^2_{ij} \\dot u_i \\dot u_j \\right)\\frac{\\partial X}{\\partial u_2}.\\] For a geodesic, we expect this to acceleration vanish. Therefore \\[\\ddot u_k + \\sum_{i,j = 1}^2 \\Gamma^k_{ij} \\dot u_i \\dot u_j  = 0, \\quad \\text{for } k=1,2. \\] This differential equation of the curves parameters \\(u(t), v(t)\\) can be solved to find a geodesic curve.\nIn the follwing implementation, a semi-analytic approach is chosen: The surface parametrization and its derivates are symbolically treated, the evaluation of Christoffel symbols and solving of the geodaetic differential equation is performed numerically. This is in our view the most flexibel and robust way, as it doesn’t require inversion of analytic functions.\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport scipy.integrate\nimport scipy.optimize\n\nfrom sympy import sin, cos, symbols, lambdify, Matrix, vector\n\n\ndef plot_surface(surface, line=None):\n    fig = plt.figure(figsize=(13,13))\n    ax = fig.add_subplot(projection='3d')\n    \n    surface = (np.squeeze(c) for c in surface) # unpack the coordinates X,Y,Z \n    ax.plot_wireframe(*surface, alpha=0.2)\n    \n    ax.set_box_aspect([ub - lb for lb, ub in (getattr(ax, f'get_{a}lim')() for a in 'xyz')])\n    \n    if line is not None: \n        line = (np.squeeze(c) for c in line)\n        ax.plot(*line, color='red', linewidth=5)\n    return ax\n\n\ndef geodesic(X, u_symbol, v_symbol, y0, tmax=10, solver_event=None):\n    \"\"\"Solve the geodesic equation given the surface X and return the curves parameters.\"\"\"\n    \n    def Christoffel_Gamma(u, v):\n        \"\"\"calculates the Christoffel symbol value at point (u,v). Needs first- and \n        second-order derivatives of euclidean X coordantes (x,y,z) with respect to the \n        plane parameters / inner coordinates (u,v)\"\"\"\n\n        # second derivates\n        dX_du2 = dX_du2_num(u, v)\n        dX_dv2 = dX_dv2_num(u, v)\n        dX_dudv = dX_dudv_num(u, v)\n\n        # first-order derivates and normal vector matrix\n        dX_du = dX_du_num(u, v)\n        dX_dv = dX_dv_num(u, v)\n        N = np.cross(dX_du, dX_dv, axis=0) # normal vector\n        dX_matrix = np.hstack([dX_du, dX_dv, N]) \n\n        # express second-order derivative in first-derivatives -&gt; Christoffel symbol\n        gamma_uu = np.linalg.solve(dX_matrix, dX_du2)[0:2]  # = \\Gamma^k_uu, k=u or v\n        gamma_uv = np.linalg.solve(dX_matrix, dX_dudv)[0:2] # = \\Gamma^k_uv, k=u or v\n        gamma_vv = np.linalg.solve(dX_matrix, dX_dv2)[0:2]  # = \\Gamma^k_vv, k=u or v\n\n        return (gamma_uu, gamma_uv, gamma_vv)\n\n    \n    def geodesic_equation(t, y):\n        \"\"\"Implements geodesic equation for ODE solver. Second-order eqn. are mapped to \n        system of first-order differential equations:  dy/dt = geodesic_eqn(t, y)\n\n        t: parameter of line\n        y:  = (u, u', v, v') with plane coordinates (u,v) and their derivatves\n        \"\"\"\n\n        u, dudt, v, dvdt = y # state variables\n\n        gamma_uu, gamma_uv, gamma_vv = Christoffel_Gamma(u, v)\n\n        # Geodesic equation, see [https://de.wikipedia.org/wiki/Christoffelsymbole]:\n        #  $$ u_k'' = -  \\sum_ij gamma^k_ij * u'_i * u'_j  for all k $$\n        # we use coordinates (u,v), these map to u_k with:  u_1 = u, u_2 = v\n\n        du_dt2 = -(gamma_uu * dudt**2 + 2 * gamma_uv * dudt * dvdt + gamma_vv * dvdt**2)\n\n        # return vector with derivatives (u', u'', v', v'')\n        derivates =  np.array([dudt, du_dt2[0,0], dvdt, du_dt2[1,0]])\n        return derivates\n\n    \n    u = u_symbol\n    v = v_symbol \n    \n    # symbolic first- and second-order derivatives\n    dX_du = X.diff(u)\n    dX_dv = X.diff(v)\n    dX_du2 = X.diff(u,u)\n    dX_dudv = X.diff(u, v)\n    dX_dv2 = X.diff(v, v)\n\n    # ... and their numerical functions\n    X_num = lambdify((u, v), X, 'numpy')\n    dX_du_num = lambdify((u, v), dX_du, 'numpy')\n    dX_dv_num = lambdify((u, v), dX_dv, 'numpy')\n    dX_du2_num = lambdify((u, v), dX_du2, 'numpy')\n    dX_dudv_num = lambdify((u, v), dX_dudv, 'numpy')\n    dX_dv2_num = lambdify((u, v), dX_dv2, 'numpy')\n        \n    sol = scipy.integrate.solve_ivp(geodesic_equation, [0, tmax], y0, dense_output=True,\n                                    events=solver_event)\n    \n    # return the solver object if events were provided, otherwise only return function\n    if solver_event:\n        return sol\n    else:\n        return lambda t: sol.sol(t)[[0,2]]  # return u and v coordinate tuple only    \n\n\n\n\nTest the geodesics calculation on a flat surface defined with polar coordinates. We expect straight line :)\n\nu, v = symbols('u v') # u = radius, v = angle phi\n\n# Express euclidean coordinates (x,y,z) in terms of plane parameters (u,v)\nX = Matrix([u * cos(v), \n            u * sin(v), \n            u * (cos(v) + sin(v))])\n\n# first-order derivatives\ndX_du = X.diff(u)\ndX_dv = X.diff(v)\n\n# ... and their numerical functions\nX_num = lambdify((u, v), X, 'numpy')\ndX_du_num = lambdify((u, v), dX_du, 'numpy')\ndX_dv_num = lambdify((u, v), dX_dv, 'numpy')\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}u \\cos{\\left(v \\right)}\\\\u \\sin{\\left(v \\right)}\\\\u \\left(\\sin{\\left(v \\right)} + \\cos{\\left(v \\right)}\\right)\\end{matrix}\\right]\\)\n\n\nJust for fun, show plane, a curve and the phi and r coordinate basis vectors:\n\n# calculate surface points for certain coordinate range\nu_grid, v_grid = np.meshgrid(np.linspace(0, 1, 100), \n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nline = X_num(0.5, np.linspace(0, 2*np.pi, 100)) # define arbitrary line\n\n# show the basis vector for the local tangent plane at some points\nu_grid, v_grid = np.meshgrid(np.linspace(0, 1, 5), \n                             np.linspace(0, 2*np.pi, 20))\npoints = X_num(u_grid, v_grid)\nvec = dX_du_num(u_grid, v_grid) /10\nvec2 = dX_dv_num(u_grid, v_grid) /10\n\nax = plot_surface(surface, line)\nax.quiver3D(*(c for c in points), *(v for v in vec), color='green')\nax.quiver3D(*(c for c in points), *(v for v in vec2), color='red');\n\n\n\n\nFor sure, the red line is not a geodesic, so let’s try to turn on the machinery…\n\n# solve the geodesic equation:\ntmax = 3             # maximum length of line\ny0 = [.5, -.5, 0, 1] # initial coordinates and derivatives (u, u', v, v'), determines direction and starting point\ng = geodesic(X, u, v, y0, tmax)\n\n# show it\nt = np.linspace(0,tmax,100)\nplot_surface(surface, X_num(g(t)[0], g(t)[1]));\n\n\n\n\nIt looks like we have a straight line, ie. a geodesic in the flat plane! :-D\nLet’s have a look at the (u,v) coordinates of the geodesic. After all, they probably look more interesting…\n\nfig = plt.figure(figsize=(10, 6))\nax = fig.add_subplot()\nax.plot(g(t)[0], g(t)[1])\nax.set_xlabel('r')\nax.set_ylabel('phi')\nplt.title('Geodesic on Flat Plane in Polar Coordinates');\n\n\n\n\n\n\n\n\nu, v = symbols('u v') # u = phi, v = angle theta\n\n# Euclidean Mapping (u,v) -&gt; (x,y,z)\nR0 = 1\nX = Matrix([R0 * cos(u)*sin(v), \n            R0 * sin(u)*sin(v), \n            R0 * cos(v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points for certain coordinate range\nu_grid, v_grid = np.meshgrid(np.linspace(0, 2*np.pi, 100), \n                             np.linspace(0, np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\n\ntmax = 10                  # maximum length of line\ny0 = [1, 1, np.pi/2+.7, 0] # initial  u, u', v, v', determines direction and starting point\ng = geodesic(X, u, v, y0, tmax)\n\n# show it\nt = np.linspace(0, tmax, 100)\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nLooks like a great circle, i.e. a geodesic. Check!\n\n\n\n\nu, v = symbols('u v')\nR0, R1 = 1, 0.25\nX = Matrix([R0 * cos(u) + R1 * cos(u) * cos(v), \n            R0 * sin(u) + R1 * sin(u) * cos(v),\n            R1 * sin(v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(0, 2*np.pi, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\n\n%matplotlib inline\n\ntmax = 7\ny0 = [0, 0, 0, 1] # point towards v coordinate\ng = geodesic(X, u, v, y0, tmax)\n\nt = np.linspace(0, tmax, 100)\nax = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n# a different geodesic:  point towards u coordinate only\ny0 = [0, 1, 0, 0] \ng = geodesic(X, u, v, y0, tmax)\n\nline = X_num(g(t)[0], g(t)[1])\nline = (np.squeeze(c) for c in line)\nax.plot(*line, color='red', linewidth=5)\n\n# a third geodesic: inclined in both parameters\ny0 = [0, .1, 0, 1]\ntmax=35\ng = geodesic(X, u, v, y0, tmax)\n\nt = np.linspace(0, tmax, 300)\nline = X_num(g(t)[0], g(t)[1])\nline = (np.squeeze(c) for c in line)\nax.plot(*line, color='green', linewidth=5)\n\n[&lt;mpl_toolkits.mplot3d.art3d.Line3D at 0x7f625415bbe0&gt;]\n\n\n\n\n\nLooks like geodesics one would expect… Check! And now to the serious stuff:\n\n\n\nTODO, might look nice…\n\n\n\n\nu, v = symbols('u v')\n\nR = 1\nX = Matrix([(R + u * cos(0.5 * v)) * cos(v),\n            (R + u * cos(0.5 * v)) * sin(v),\n            u * sin(0.5 * v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(-1, 1, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}\\left(u \\cos{\\left(0.5 v \\right)} + 1\\right) \\cos{\\left(v \\right)}\\\\\\left(u \\cos{\\left(0.5 v \\right)} + 1\\right) \\sin{\\left(v \\right)}\\\\u \\sin{\\left(0.5 v \\right)}\\end{matrix}\\right]\\)\n\n\n\n\nWe don’t want to find any geodesic, but a closed one. Therefore we need some preparations. Starting the geodesic at a point (u,v), we need to find the good direction to shoot if off, in order to hit the same point after roundtrip again:\n\ntmax = 5      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = 0   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target = - u_start          # Möbius strip: u -&gt; -u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\n\ndef closed_loop_metric(du_dt):\n    \"\"\"Returns a measure of how good we got a closed loop given a du/dt starting direction.\"\"\"\n    \n    def u_crossing_event(t, y):\n        \"\"\"Used in scipy.integrate.solve_ivp(event=) of geodesics() function, \n        used to detect target u values -&gt; potential closed loop.\"\"\"\n        return (y[0] - u_end_target) \n   \n    y0 = [u_start, du_dt, v_start, 1]  # fixed dv/dt=1 in order to go along strip\n    g = geodesic(X, u, v, y0 , tmax, solver_event=u_crossing_event)\n    \n    #print(g.y_events)\n    if len(g.y_events[0]) == 0:\n        return 100\n    \n    # find v in events of u_end_target crossings, which is closest to v_end_target\n    closest_idx = np.argmin(abs(g.y_events[0][:, 2] - v_end_target))\n    u_end, v_end = g.y_events[0][closest_idx, [0,2]]\n                            \n    return (u_end_target - u_end)**2 + (v_end_target - v_end)**2\n\nWith that, we can searching optimal du/dt direction. (Set some starting point in the neighbourhood, which can be ound by studying geodesic (u,v) plots manually)\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[-.7, -.8])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 1.858207977514734e-14\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 23\n     nit: 18\n success: True\n       x: -1.5117115896978943\n\n\nLet’s have a look at this curve with the found du/dt value:\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\n%matplotlib inline\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nWhile we arrived at the same starting pint, the geodesics cuts itself at an angle and is not closed.\n\n\n\nExperimenting with the initial values showed that (u,v)=(0,\\(\\pi\\)) might yield better results:\n\ntmax = 5      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target = - u_start          # Möbius strip: u -&gt; -u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction. ( See Experiments section below for chosen starting points 0.5, 0.51)\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.5, 0.51])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 4.479991192779563e-13\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 25\n     nit: 17\n success: True\n       x: 0.6641064541349162\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nHere we arrived at a properly closed geodesic on the Möbius strip. Other starting value for u_start might yield others as well.\n\n\n\n\nThree times twisted strip\n\nu, v = symbols('u v')\n\nR = 1\nX = Matrix([(R + u * cos(1.5 * v)) * cos(v),\n            (R + u * cos(1.5 * v)) * sin(v),\n            u * sin(1.5 * v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(-.5, .5, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}\\left(u \\cos{\\left(1.5 v \\right)} + 1\\right) \\cos{\\left(v \\right)}\\\\\\left(u \\cos{\\left(1.5 v \\right)} + 1\\right) \\sin{\\left(v \\right)}\\\\u \\sin{\\left(1.5 v \\right)}\\end{matrix}\\right]\\)\n\n\nSearch a closed geodesic:\n\ntmax = 6    # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi/2/1.5   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target =  - u_start         # Möbius strip: u -&gt; u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction.\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.2, 0.3])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 7.121210237517629e-11\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 34\n     nit: 30\n success: True\n       x: 0.31788575631551347\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nWe successfully arrived at the closed geodesics! let’s export the data:\n\n\n\n\nu, v = symbols('u v')\n\nR = 1\nX = Matrix([(R + u * cos(1 * v)) * cos(v),\n            (R + u * cos(1 * v)) * sin(v),\n            u * sin(1 * v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(-.5, .5, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}\\left(u \\cos{\\left(v \\right)} + 1\\right) \\cos{\\left(v \\right)}\\\\\\left(u \\cos{\\left(v \\right)} + 1\\right) \\sin{\\left(v \\right)}\\\\u \\sin{\\left(v \\right)}\\end{matrix}\\right]\\)\n\n\n\n\n\ntmax = 6      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target =  u_start          # non-Möbius strip: u -&gt; u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction.\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.5, 0.51])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 1.9317193557273604e-12\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 24\n     nit: 17\n success: True\n       x: 0.5568187609997342\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\nThese (u,v) coordinates show that we dont have a closed geodesic. New try…\n\n\n\n\ntmax = 6      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi/2   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target =  u_start          # non-Möbius strip: u -&gt; u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction.\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.3, .31])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 1.1346961251873202e-13\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 25\n     nit: 18\n success: True\n       x: 0.4467328464205437\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nWe successfully arrived at a closed geodesic on the doubly twisted strip!"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#helper-functions",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#helper-functions",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n\nimport scipy.integrate\nimport scipy.optimize\n\nfrom sympy import sin, cos, symbols, lambdify, Matrix, vector\n\n\ndef plot_surface(surface, line=None):\n    fig = plt.figure(figsize=(13,13))\n    ax = fig.add_subplot(projection='3d')\n    \n    surface = (np.squeeze(c) for c in surface) # unpack the coordinates X,Y,Z \n    ax.plot_wireframe(*surface, alpha=0.2)\n    \n    ax.set_box_aspect([ub - lb for lb, ub in (getattr(ax, f'get_{a}lim')() for a in 'xyz')])\n    \n    if line is not None: \n        line = (np.squeeze(c) for c in line)\n        ax.plot(*line, color='red', linewidth=5)\n    return ax\n\n\ndef geodesic(X, u_symbol, v_symbol, y0, tmax=10, solver_event=None):\n    \"\"\"Solve the geodesic equation given the surface X and return the curves parameters.\"\"\"\n    \n    def Christoffel_Gamma(u, v):\n        \"\"\"calculates the Christoffel symbol value at point (u,v). Needs first- and \n        second-order derivatives of euclidean X coordantes (x,y,z) with respect to the \n        plane parameters / inner coordinates (u,v)\"\"\"\n\n        # second derivates\n        dX_du2 = dX_du2_num(u, v)\n        dX_dv2 = dX_dv2_num(u, v)\n        dX_dudv = dX_dudv_num(u, v)\n\n        # first-order derivates and normal vector matrix\n        dX_du = dX_du_num(u, v)\n        dX_dv = dX_dv_num(u, v)\n        N = np.cross(dX_du, dX_dv, axis=0) # normal vector\n        dX_matrix = np.hstack([dX_du, dX_dv, N]) \n\n        # express second-order derivative in first-derivatives -&gt; Christoffel symbol\n        gamma_uu = np.linalg.solve(dX_matrix, dX_du2)[0:2]  # = \\Gamma^k_uu, k=u or v\n        gamma_uv = np.linalg.solve(dX_matrix, dX_dudv)[0:2] # = \\Gamma^k_uv, k=u or v\n        gamma_vv = np.linalg.solve(dX_matrix, dX_dv2)[0:2]  # = \\Gamma^k_vv, k=u or v\n\n        return (gamma_uu, gamma_uv, gamma_vv)\n\n    \n    def geodesic_equation(t, y):\n        \"\"\"Implements geodesic equation for ODE solver. Second-order eqn. are mapped to \n        system of first-order differential equations:  dy/dt = geodesic_eqn(t, y)\n\n        t: parameter of line\n        y:  = (u, u', v, v') with plane coordinates (u,v) and their derivatves\n        \"\"\"\n\n        u, dudt, v, dvdt = y # state variables\n\n        gamma_uu, gamma_uv, gamma_vv = Christoffel_Gamma(u, v)\n\n        # Geodesic equation, see [https://de.wikipedia.org/wiki/Christoffelsymbole]:\n        #  $$ u_k'' = -  \\sum_ij gamma^k_ij * u'_i * u'_j  for all k $$\n        # we use coordinates (u,v), these map to u_k with:  u_1 = u, u_2 = v\n\n        du_dt2 = -(gamma_uu * dudt**2 + 2 * gamma_uv * dudt * dvdt + gamma_vv * dvdt**2)\n\n        # return vector with derivatives (u', u'', v', v'')\n        derivates =  np.array([dudt, du_dt2[0,0], dvdt, du_dt2[1,0]])\n        return derivates\n\n    \n    u = u_symbol\n    v = v_symbol \n    \n    # symbolic first- and second-order derivatives\n    dX_du = X.diff(u)\n    dX_dv = X.diff(v)\n    dX_du2 = X.diff(u,u)\n    dX_dudv = X.diff(u, v)\n    dX_dv2 = X.diff(v, v)\n\n    # ... and their numerical functions\n    X_num = lambdify((u, v), X, 'numpy')\n    dX_du_num = lambdify((u, v), dX_du, 'numpy')\n    dX_dv_num = lambdify((u, v), dX_dv, 'numpy')\n    dX_du2_num = lambdify((u, v), dX_du2, 'numpy')\n    dX_dudv_num = lambdify((u, v), dX_dudv, 'numpy')\n    dX_dv2_num = lambdify((u, v), dX_dv2, 'numpy')\n        \n    sol = scipy.integrate.solve_ivp(geodesic_equation, [0, tmax], y0, dense_output=True,\n                                    events=solver_event)\n    \n    # return the solver object if events were provided, otherwise only return function\n    if solver_event:\n        return sol\n    else:\n        return lambda t: sol.sol(t)[[0,2]]  # return u and v coordinate tuple only"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#flat-plane-in-polar-coordinates",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#flat-plane-in-polar-coordinates",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "Test the geodesics calculation on a flat surface defined with polar coordinates. We expect straight line :)\n\nu, v = symbols('u v') # u = radius, v = angle phi\n\n# Express euclidean coordinates (x,y,z) in terms of plane parameters (u,v)\nX = Matrix([u * cos(v), \n            u * sin(v), \n            u * (cos(v) + sin(v))])\n\n# first-order derivatives\ndX_du = X.diff(u)\ndX_dv = X.diff(v)\n\n# ... and their numerical functions\nX_num = lambdify((u, v), X, 'numpy')\ndX_du_num = lambdify((u, v), dX_du, 'numpy')\ndX_dv_num = lambdify((u, v), dX_dv, 'numpy')\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}u \\cos{\\left(v \\right)}\\\\u \\sin{\\left(v \\right)}\\\\u \\left(\\sin{\\left(v \\right)} + \\cos{\\left(v \\right)}\\right)\\end{matrix}\\right]\\)\n\n\nJust for fun, show plane, a curve and the phi and r coordinate basis vectors:\n\n# calculate surface points for certain coordinate range\nu_grid, v_grid = np.meshgrid(np.linspace(0, 1, 100), \n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nline = X_num(0.5, np.linspace(0, 2*np.pi, 100)) # define arbitrary line\n\n# show the basis vector for the local tangent plane at some points\nu_grid, v_grid = np.meshgrid(np.linspace(0, 1, 5), \n                             np.linspace(0, 2*np.pi, 20))\npoints = X_num(u_grid, v_grid)\nvec = dX_du_num(u_grid, v_grid) /10\nvec2 = dX_dv_num(u_grid, v_grid) /10\n\nax = plot_surface(surface, line)\nax.quiver3D(*(c for c in points), *(v for v in vec), color='green')\nax.quiver3D(*(c for c in points), *(v for v in vec2), color='red');\n\n\n\n\nFor sure, the red line is not a geodesic, so let’s try to turn on the machinery…\n\n# solve the geodesic equation:\ntmax = 3             # maximum length of line\ny0 = [.5, -.5, 0, 1] # initial coordinates and derivatives (u, u', v, v'), determines direction and starting point\ng = geodesic(X, u, v, y0, tmax)\n\n# show it\nt = np.linspace(0,tmax,100)\nplot_surface(surface, X_num(g(t)[0], g(t)[1]));\n\n\n\n\nIt looks like we have a straight line, ie. a geodesic in the flat plane! :-D\nLet’s have a look at the (u,v) coordinates of the geodesic. After all, they probably look more interesting…\n\nfig = plt.figure(figsize=(10, 6))\nax = fig.add_subplot()\nax.plot(g(t)[0], g(t)[1])\nax.set_xlabel('r')\nax.set_ylabel('phi')\nplt.title('Geodesic on Flat Plane in Polar Coordinates');"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#sphere",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#sphere",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "u, v = symbols('u v') # u = phi, v = angle theta\n\n# Euclidean Mapping (u,v) -&gt; (x,y,z)\nR0 = 1\nX = Matrix([R0 * cos(u)*sin(v), \n            R0 * sin(u)*sin(v), \n            R0 * cos(v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points for certain coordinate range\nu_grid, v_grid = np.meshgrid(np.linspace(0, 2*np.pi, 100), \n                             np.linspace(0, np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\n\ntmax = 10                  # maximum length of line\ny0 = [1, 1, np.pi/2+.7, 0] # initial  u, u', v, v', determines direction and starting point\ng = geodesic(X, u, v, y0, tmax)\n\n# show it\nt = np.linspace(0, tmax, 100)\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nLooks like a great circle, i.e. a geodesic. Check!"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#torus",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#torus",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "u, v = symbols('u v')\nR0, R1 = 1, 0.25\nX = Matrix([R0 * cos(u) + R1 * cos(u) * cos(v), \n            R0 * sin(u) + R1 * sin(u) * cos(v),\n            R1 * sin(v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(0, 2*np.pi, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\n\n%matplotlib inline\n\ntmax = 7\ny0 = [0, 0, 0, 1] # point towards v coordinate\ng = geodesic(X, u, v, y0, tmax)\n\nt = np.linspace(0, tmax, 100)\nax = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n# a different geodesic:  point towards u coordinate only\ny0 = [0, 1, 0, 0] \ng = geodesic(X, u, v, y0, tmax)\n\nline = X_num(g(t)[0], g(t)[1])\nline = (np.squeeze(c) for c in line)\nax.plot(*line, color='red', linewidth=5)\n\n# a third geodesic: inclined in both parameters\ny0 = [0, .1, 0, 1]\ntmax=35\ng = geodesic(X, u, v, y0, tmax)\n\nt = np.linspace(0, tmax, 300)\nline = X_num(g(t)[0], g(t)[1])\nline = (np.squeeze(c) for c in line)\nax.plot(*line, color='green', linewidth=5)\n\n[&lt;mpl_toolkits.mplot3d.art3d.Line3D at 0x7f625415bbe0&gt;]\n\n\n\n\n\nLooks like geodesics one would expect… Check! And now to the serious stuff:"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#cone",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#cone",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "TODO, might look nice…"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#möbius-strip",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#möbius-strip",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "u, v = symbols('u v')\n\nR = 1\nX = Matrix([(R + u * cos(0.5 * v)) * cos(v),\n            (R + u * cos(0.5 * v)) * sin(v),\n            u * sin(0.5 * v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(-1, 1, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}\\left(u \\cos{\\left(0.5 v \\right)} + 1\\right) \\cos{\\left(v \\right)}\\\\\\left(u \\cos{\\left(0.5 v \\right)} + 1\\right) \\sin{\\left(v \\right)}\\\\u \\sin{\\left(0.5 v \\right)}\\end{matrix}\\right]\\)\n\n\n\n\nWe don’t want to find any geodesic, but a closed one. Therefore we need some preparations. Starting the geodesic at a point (u,v), we need to find the good direction to shoot if off, in order to hit the same point after roundtrip again:\n\ntmax = 5      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = 0   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target = - u_start          # Möbius strip: u -&gt; -u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\n\ndef closed_loop_metric(du_dt):\n    \"\"\"Returns a measure of how good we got a closed loop given a du/dt starting direction.\"\"\"\n    \n    def u_crossing_event(t, y):\n        \"\"\"Used in scipy.integrate.solve_ivp(event=) of geodesics() function, \n        used to detect target u values -&gt; potential closed loop.\"\"\"\n        return (y[0] - u_end_target) \n   \n    y0 = [u_start, du_dt, v_start, 1]  # fixed dv/dt=1 in order to go along strip\n    g = geodesic(X, u, v, y0 , tmax, solver_event=u_crossing_event)\n    \n    #print(g.y_events)\n    if len(g.y_events[0]) == 0:\n        return 100\n    \n    # find v in events of u_end_target crossings, which is closest to v_end_target\n    closest_idx = np.argmin(abs(g.y_events[0][:, 2] - v_end_target))\n    u_end, v_end = g.y_events[0][closest_idx, [0,2]]\n                            \n    return (u_end_target - u_end)**2 + (v_end_target - v_end)**2\n\nWith that, we can searching optimal du/dt direction. (Set some starting point in the neighbourhood, which can be ound by studying geodesic (u,v) plots manually)\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[-.7, -.8])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 1.858207977514734e-14\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 23\n     nit: 18\n success: True\n       x: -1.5117115896978943\n\n\nLet’s have a look at this curve with the found du/dt value:\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\n%matplotlib inline\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nWhile we arrived at the same starting pint, the geodesics cuts itself at an angle and is not closed.\n\n\n\nExperimenting with the initial values showed that (u,v)=(0,\\(\\pi\\)) might yield better results:\n\ntmax = 5      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target = - u_start          # Möbius strip: u -&gt; -u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction. ( See Experiments section below for chosen starting points 0.5, 0.51)\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.5, 0.51])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 4.479991192779563e-13\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 25\n     nit: 17\n success: True\n       x: 0.6641064541349162\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nHere we arrived at a properly closed geodesic on the Möbius strip. Other starting value for u_start might yield others as well."
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#triple-twisted-strip",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#triple-twisted-strip",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "Three times twisted strip\n\nu, v = symbols('u v')\n\nR = 1\nX = Matrix([(R + u * cos(1.5 * v)) * cos(v),\n            (R + u * cos(1.5 * v)) * sin(v),\n            u * sin(1.5 * v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(-.5, .5, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}\\left(u \\cos{\\left(1.5 v \\right)} + 1\\right) \\cos{\\left(v \\right)}\\\\\\left(u \\cos{\\left(1.5 v \\right)} + 1\\right) \\sin{\\left(v \\right)}\\\\u \\sin{\\left(1.5 v \\right)}\\end{matrix}\\right]\\)\n\n\nSearch a closed geodesic:\n\ntmax = 6    # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi/2/1.5   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target =  - u_start         # Möbius strip: u -&gt; u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction.\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.2, 0.3])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 7.121210237517629e-11\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 34\n     nit: 30\n success: True\n       x: 0.31788575631551347\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nWe successfully arrived at the closed geodesics! let’s export the data:"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#doubly-twisted-strip",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#doubly-twisted-strip",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "u, v = symbols('u v')\n\nR = 1\nX = Matrix([(R + u * cos(1 * v)) * cos(v),\n            (R + u * cos(1 * v)) * sin(v),\n            u * sin(1 * v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(-.5, .5, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}\\left(u \\cos{\\left(v \\right)} + 1\\right) \\cos{\\left(v \\right)}\\\\\\left(u \\cos{\\left(v \\right)} + 1\\right) \\sin{\\left(v \\right)}\\\\u \\sin{\\left(v \\right)}\\end{matrix}\\right]\\)\n\n\n\n\n\ntmax = 6      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target =  u_start          # non-Möbius strip: u -&gt; u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction.\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.5, 0.51])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 1.9317193557273604e-12\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 24\n     nit: 17\n success: True\n       x: 0.5568187609997342\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\nThese (u,v) coordinates show that we dont have a closed geodesic. New try…\n\n\n\n\ntmax = 6      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi/2   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target =  u_start          # non-Möbius strip: u -&gt; u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction.\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.3, .31])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 1.1346961251873202e-13\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 25\n     nit: 18\n success: True\n       x: 0.4467328464205437\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nWe successfully arrived at a closed geodesic on the doubly twisted strip!"
  },
  {
    "objectID": "posts/gps/intro.html",
    "href": "posts/gps/intro.html",
    "title": "GPS Walkthrough – Series Introduction",
    "section": "",
    "text": "Have you ever wondered about how the Global Positioning System (GPS) actually works in detail? I did as well, and wanted to dive into it one day. I said to myself, better buy a HackRF and a GPS antenna to be prepared for this moment, which took some time to come…\nAt the beginning of 2023, I stumbled across the very nice article by Ankur Mohan about “Calculating Position from Raw GPS Data”. It finally kindled my motivation to start the long forseen hobby project. While Ankur’s article covers many interesting aspects of GPS, some are missing due to the fact that he relies on a GPS receiver which takes care of radio wave processing and time-of-flight calculation.\nI wanted to fill in these gaps with a little hobby project, since my original motivation was to know GPS from radio wave to position fix. At first, it was at unclear how realistic this goal is. But here we are, after some long nights, things fall into place and I finally know my balcony’s GPS coordinates!\nDue to the very diverse topics involved, I found that it might be interesting for others as well. The idea of a walkthrough was born, where we go step-by-step together with theoretical explanations, practical number-crunching and visualizations along the way. To be honest: This journey involves quite a deal of machinery. But in order achieve the goal to really understand it in-depth, we will never rely on black boxes (like high-level software routines) but start from first-principles available to anyone with some highschool math background or good motivation to look things up. Be prepared to learn about\n\nradio waves and their mathematical description,\nradio receivers and their inner workings,\nradio signal modulation and demodulation,\ndigital signal processing, filters, and control loops,\nGPS (!), its radio signal, telemetry data, and coordinate systems,\na little physics, as in Doppler shift, Sagnac effect, relativistic time dilation, and orbit calculation,\nflat earth hypothesis is rather difficult to defend considering the results we get here,\nand the metric system might be not such a bad idea after all.\n\nIn case you managed to read this far and are still interested, despite of these details we will have to deal with, you are very welcome to continue with me. I promise that at the end we will find the location of my (or your) balcony to better than 2 meters accuracy within a volume of space of more than 25’000 km in diameter!"
  },
  {
    "objectID": "posts/gps/intro.html#introduction",
    "href": "posts/gps/intro.html#introduction",
    "title": "GPS Walkthrough – Series Introduction",
    "section": "",
    "text": "Have you ever wondered about how the Global Positioning System (GPS) actually works in detail? I did as well, and wanted to dive into it one day. I said to myself, better buy a HackRF and a GPS antenna to be prepared for this moment, which took some time to come…\nAt the beginning of 2023, I stumbled across the very nice article by Ankur Mohan about “Calculating Position from Raw GPS Data”. It finally kindled my motivation to start the long forseen hobby project. While Ankur’s article covers many interesting aspects of GPS, some are missing due to the fact that he relies on a GPS receiver which takes care of radio wave processing and time-of-flight calculation.\nI wanted to fill in these gaps with a little hobby project, since my original motivation was to know GPS from radio wave to position fix. At first, it was at unclear how realistic this goal is. But here we are, after some long nights, things fall into place and I finally know my balcony’s GPS coordinates!\nDue to the very diverse topics involved, I found that it might be interesting for others as well. The idea of a walkthrough was born, where we go step-by-step together with theoretical explanations, practical number-crunching and visualizations along the way. To be honest: This journey involves quite a deal of machinery. But in order achieve the goal to really understand it in-depth, we will never rely on black boxes (like high-level software routines) but start from first-principles available to anyone with some highschool math background or good motivation to look things up. Be prepared to learn about\n\nradio waves and their mathematical description,\nradio receivers and their inner workings,\nradio signal modulation and demodulation,\ndigital signal processing, filters, and control loops,\nGPS (!), its radio signal, telemetry data, and coordinate systems,\na little physics, as in Doppler shift, Sagnac effect, relativistic time dilation, and orbit calculation,\nflat earth hypothesis is rather difficult to defend considering the results we get here,\nand the metric system might be not such a bad idea after all.\n\nIn case you managed to read this far and are still interested, despite of these details we will have to deal with, you are very welcome to continue with me. I promise that at the end we will find the location of my (or your) balcony to better than 2 meters accuracy within a volume of space of more than 25’000 km in diameter!"
  },
  {
    "objectID": "posts/gps/intro.html#walkthrough-steps",
    "href": "posts/gps/intro.html#walkthrough-steps",
    "title": "GPS Walkthrough – Series Introduction",
    "section": "Walkthrough Steps",
    "text": "Walkthrough Steps\nThe GPS walkthrough investigates the GPS L1 C/A signal1, from radio wave to position fix, by performing all calculations in Python using NumPy. It consists of the following steps, each with its dedicated blog post:\n\n\n\n\n\n\nJupyter Notebooks\n\n\n\nYou want to follow the steps by computing the results yourself or applying it on your own signals? Check out the Jupyter notebooks which will be published simultaneously with the blog posts on gps-walkthrough repository.\n\n\n\nOverview: This post gives an overview by quickly going over all steps and their results, i.e. from radio wave recording to the calculation of the position fix. Detailed analysis and explanations are lacking here. I hope this motivates you to dive deeper in the following.\nRadio Wave Recording: I explain how to use the HackRF receiver and a GPS antenna for recording of the GPS radio wave. In case this hardware equipment is not available, it is shown how to be generated artificially. The recording is read and analyzed for signal quality.\nFor getting an understanding of the recorded data as required later, a mathematical model of the radio wave is introduced and the basic principles of a radio receiver sketched. We look into numerical examples and their visualizations for intuition of the theory, as well as an introduction to NumPy.\n\n\n\n\n\n\n\nRecord your own GPS signal?\n\n\n\n\n\nYou want to record your own GPS signal and analyze it? This equipment is needed:\n\nSDR receiver (e.g. HackRF or RTL-based) capable to receive at 1575 MHz. Unlike other GPS software receivers, no precise clock reference is required here.\nActive GPS antenna with at least 25dB gain. A cheap 10$ one is sufficient (e.g. MikroTik ACGPSA).\nBias tee voltage supply if the SDR does not support powering the antenna. (Not required for HackRF with antennas accepting 3.3 Volts.)\n\nAfter having this available, be patient for this post to get published for detailed instructions…\n\n\n\n\nGPS Signal Theory and Acquisition: GPS Signals are very weak, even fainter than background noise of the environment. Knowledge of the sent signal type is required in order to detect it using correlation techniques. Here we investigate the specific nature of the GPS signal, play with its properties.\nFurthermore, we have to discuss effects which distort the received signal. Having this in mind, we finally are able to detect the GPS signal in our recording and identify the available satellites and their signal strength.\nSignal Tracking: The former acquisition step needed to perform a blind search for every satellite, which showed to be rather instable to noisy signals and expensive in terms of computation time, even for very short time periods. But once that we found a signal by this procedure, we will find out together how to lock onto it and keep reception stable. This allows us to demodulate the data stream being sent efficiently.\nTelemetry Decoding and Orbital Position Calculation: Having a demodulated signal at hand, we get the transmitted bits and bytes after a little synchronization procedure. We dive a little into the specs of GPS. This allows us interpret the telemetry messages with its very precise send time information and orbital parameters.\nUsing telemetry information, we can calculate the position of every satellite at every instant of time. Despite their high velocity (4 km/s), this better happens at an accuracy below a few meters, since the quality of our position fix will directly depend on it.\nPseudo-Range and Position Fix Calculation: The send time information and the actual moment of reception, as measured by our receiver’s clock, allows us to determine the time-of-flight of the signal from every satellite independently. Since we have no atomic but a cheap, inaccurate receiver clock, we will need to compensate for this accordingly. The time-of-flight translates to an apparent distance (pseudo-range) due to the constant speed of light.\nHaving come this far, we know for every moment in our recording the positions of every satellite and their distance from us. Using suitable optimization methods, we can find our position with a few meters accuracy within the huge space spanning tens of thousands of kilometers!\n\nPlease be patient for these announced posts to be published and motivate me with encouraging comments 🙂 If you want to be noticed about it, subscribe to my newsletter. Already available posts are:"
  },
  {
    "objectID": "posts/gps/intro.html#footnotes",
    "href": "posts/gps/intro.html#footnotes",
    "title": "GPS Walkthrough – Series Introduction",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nFor GPS L1 C/A details, see https://gssc.esa.int/navipedia/index.php/GPS_Signal_Plan#GPS_L1_Band and https://en.wikipedia.org/wiki/GPS_signals#Legacy_GPS_signals.↩︎"
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html",
    "title": "Polygon Smoothing Riddle",
    "section": "",
    "text": "A random polygon evolves into an ellipse if we iteratively generate a new polygons with its edges being the center of the previous polygon: https://www.jasondavies.com/random-polygon-ellipse/\nThis phenomenon was recently brought forward in a notable but private discussion board by Dr. R. M. Of course, the following questions immediatley arise:\nWe try to address these in the following."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#definition",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#definition",
    "title": "Polygon Smoothing Riddle",
    "section": "Definition",
    "text": "Definition\nWe represent polygon points by numbers in the complex plane. This will turn out to lead to an elegant description of the phenomenon.\nThe averaging / smoothing of the polygon by calculating the point centers is implemented with\n\nimport numpy as np\n\ndef do_smoothing(points, steps):\n    \"\"\"Build average of neighboring points, apply it multiple times.\"\"\"\n    \n    for i in range(steps):\n        points = (points + np.roll(points, 1))/2 \n        \n    return points\n\nWe need to visualize a list of points as polygons in the following. We define this helper function by\n\nimport matplotlib.pyplot as plt\n\ndef show_points(points, ax=None, labels=True, dots=True, linewidth=0.5):\n    \"\"\"Plot all points in complex plane. If given, use the axis given, otherwise build new figure.\"\"\"\n    \n    X = [x.real for x in points]\n    Y = [x.imag for x in points]\n    X.append(X[0]) # start point is end point\n    Y.append(Y[0])\n    \n    if ax == None:\n        fig = plt.figure(figsize=[4,4])\n        ax = fig.add_subplot(111)\n        \n    ax.set_aspect('equal', 'datalim')\n\n    if dots: ax.scatter(X,Y, color='red')\n    ax.plot(X,Y, color='black', linewidth=linewidth)\n    \n    if labels:\n        for i in range(len(points)):\n            ax.annotate(i, (X[i], Y[i]), textcoords=\"offset points\", xytext=(0,10))"
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#polygon-evolution-example",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#polygon-evolution-example",
    "title": "Polygon Smoothing Riddle",
    "section": "Polygon Evolution Example",
    "text": "Polygon Evolution Example\nLet us reproduce the phenomenon with an example. A random polygon is chosen by\n\nN = 13\ninit_points = np.random.standard_normal(N) + np.random.standard_normal(N)*1j\nshow_points(init_points)\n\n\n\n\nLet the smoothing process evolve:\n\npoints = init_points\n\n# iterate smoothing:\nsteps = 3 # steps between plots\nplt.figure(figsize=[10,10]) \nfor i in range(16):\n    ax = plt.subplot(4,4,i+1)\n    show_points(points, ax)\n    points = do_smoothing(points, steps)\n\n\n\n\n\nAnswer to 2. Question\nWhy we observe 45° alignment can be answered here: We don’t observe that at all.\nThis peculiar alignment was an artifact of the zooming method which was used in [1]: While we iterate, the polygons get smaller in radius. If we zoom in X and Y direction independently, we will always make it look like being on a diagonal. The alignment is enforced by the zooming and has nothing to do with the smoothing procedure.\nAbove we use a uniform zoom factor (equal axis), which doesn’t break the rotation symmetry and thereby conserves to true alignment of the ellipse."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#prediction-of-final-ellipse",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#prediction-of-final-ellipse",
    "title": "Polygon Smoothing Riddle",
    "section": "Prediction of Final Ellipse",
    "text": "Prediction of Final Ellipse\nThe smoothing procedure is a linear operation which can be formulated in a matrix representation. \\[\\mathbb S \\, \\bf x_k = \\bf x_{k+1}\\]\nTo simplify the analysis, we can recall our QT lectures and do an eigenstate decomposition. Eigenstates (or eigenpolygons) do not change their shape shape under the smoothing operation but are only shrinked and rotated by a complex prefactor (eigenvalue).\n\\[ \\mathbb S \\, \\bf{ x} = \\lambda \\bf{ x} \\]\n\nDominant Eigenstates\nOf course we could do a more strict analysis, but let’s do it physicist free-style way (although Dr. S. wasn’t very happy with that…):\nWe found from numerical calculation (eigenstate analysis) of some polybon point numbers N, that circlular arrangements are eigenstates. They have the largest eigenvalue, i.e. they are the least suppressed/decreased in size from generation to generation, while all the other eigenstates converge faster to zero extend. We have observed this for N=3 and 5, so it must be a very general fact, right?\nTherefore, after a few iterations, circles are the only surviving contribution, everything else decreases much faster in size. So lets phrase the\nHypothesis: Circles are dominant eigenstates under the smoothing operation.\nThere are two independent cicular arrangments, namely\n\neigenstate1 = [np.exp(1j* 2*np.pi/N * k) for k in range(N)]  # clockwise orientation\neigenstate2 = [np.exp(-1j* 2*np.pi/N * k) for k in range(N)] # counter-clockwise orientation\n\nshow_points(eigenstate1, plt.subplot(121))\nshow_points(eigenstate2, plt.subplot(122))\n\n\n\n\nNote their clock/counter-clockwise orientation. Let’s check whether these are really eigenstates:\n\npoints = eigenstate1\n\n# iterate smoothing:\nn = 7\nplt.figure(figsize=[15,3]) \nfor i in range(n):\n    ax = plt.subplot(1,n,i+1)\n    show_points(points, ax)\n    points = do_smoothing(points, 1)\n\n\n\n\nApparently they are. They turn around, but that’s fine as it only is a complex prefactor introducing the turning and shrinking:\n\ndo_smoothing(eigenstate1, 1) / eigenstate1\n\narray([0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j])\n\n\nWorks out as expected. we even get the eigenvalues for free.\n\neigenvalue1 = (do_smoothing(eigenstate1, 1) / eigenstate1)[0]\neigenvalue2 = (do_smoothing(eigenstate2, 1) / eigenstate2)[0]\n\neigenvalue1, eigenvalue2\n\n((0.9427280128266048-0.2323615860218846j),\n (0.9427280128266048+0.2323615860218846j))\n\n\n\n\nDecompose Initial State into Eigenstates\nIn order to find out how much of the eigenstates are included in our random initial state, we project the inital state onto the eigenvectors. This calls for the use of an inner product, which we readily have at hand with the familiar\n\ndef dot(v1, v2):\n    \"\"\"Dot Product between complex vectors\"\"\"\n    return np.dot(v1, np.conj(v2))\n\nLike in the good old QT days with Prof. H., we do first a normalization and check\n\neigenstate1 = eigenstate1 / np.sqrt(dot(eigenstate1, eigenstate1))\neigenstate2 = eigenstate2 / np.sqrt(dot(eigenstate2, eigenstate2))\n\ndot(eigenstate1, eigenstate1), dot(eigenstate2, eigenstate2)\n\n((1+0j), (1+0j))\n\n\nNicely normalized: Check. We can proceed:\nNow, let’s do the projection and get the complex coefficients\n\nc1 = dot(init_points, eigenstate1)\nc2 = dot(init_points, eigenstate2)\n\nc1, c2\n\n((0.5149093832008008-1.950855436819647j),\n (0.07602149507747744+1.113740507931655j))\n\n\nGood, both eigenstates seem to be present in there. What can we do with that?\n\n\nRepresentation as Ellipse\nAn general ellipse is parametrized by \\(\\varphi\\) with \\(a,b\\) being the half axis and \\(\\theta\\) a rotation angle. We define\n\ndef ellipse(a,b, phi, theta): \n    \"\"\"get coordinates of ellipse with half axes a,b rotated with theta, along parameter phi.\"\"\"\n    \n    c, s = a*np.cos(phi), b*np.sin(phi) \n    x = (s, c) # ellipse coordinate vector\n    \n    # rotate it\n    c, s = np.cos(theta), np.sin(theta)\n    R = np.array(((c, -s), (s, c))) # rotation matrix\n    x_rot = np.matmul(R, x)\n    \n    return x_rot[0] + 1j * x_rot[1] # go to complex representation\n\nAs our calculations show (they are still only on our window and wait to be transfered to the appendix in due time, of course), a superposition of both eigenstates result in a ellipse with the following parameters\n\\[ a = \\left|\\frac{|c_1| - |c_2|}{\\sqrt N}\\right|, \\quad b  = \\frac{|c_1| + |c_2|}{\\sqrt N} \\]\nand \\[ \\theta = \\frac{\\arg{c_1} + \\arg{c_2}}{2}\\]\nSo let’s give it a try:\n\nsteps = 300 # how many steps to iterate \n\n# propagete eigenstates through smoothing operation by mulitplying eigenvalue 'steps' times\nc1_it = c1 * np.power(eigenvalue1, steps)\nc2_it = c2 * np.power(eigenvalue2, steps)\n\n# magic, analytic formulas\na = np.abs(np.abs(c1_it) - np.abs(c2_it)) / np.sqrt(N) \nb = (np.abs(c1_it) + np.abs(c2_it)) / np.sqrt(N) \ntheta = (np.angle(c1_it) + np.angle(c2_it)) / 2\n\nellipse_pts = [ellipse(a, b, phi, theta) for phi in np.linspace(0, 2*np.pi, 50)]\n\nax = plt.subplot(111)\nshow_points(ellipse_pts, labels=False, dots=False, ax=ax, linewidth=2)\n\nshow_points(do_smoothing(init_points - np.mean(init_points), steps), labels=False,ax=ax)\n\n\n\n\nThe comparison between the predicted shape and iteratively computed point distribution is rather satisfying.\nAs an encore, we provide the comparison of the prediction based only on the two dominant eigenvalues in comparison to the computed iterated polygon:\n\ndef show_iteration_vs_dominantEigenstates(): \n    points = np.random.standard_normal(N) + np.random.standard_normal(N)*1j\n    points = points - np.mean(points)\n\n    c1 = dot(points, eigenstate1)\n    c2 = dot(points, eigenstate2)\n\n    steps = 3 # steps between plots\n\n    plt.figure(figsize=[10,10])\n\n    for i in range(16):\n        ax = plt.subplot(4, 4, i+1)\n        \n        # show smoothed points\n        show_points(points, ax, labels=False)\n\n        # now, calculate our analytic prediction ellipse for this iteration:\n\n        # propagete eigenstates through smoothing operation by mulitplying eigenvalue 'steps' times\n        c1_it = c1 * np.power(eigenvalue1, i*steps)\n        c2_it = c2 * np.power(eigenvalue2, i*steps)\n\n        a = np.abs(np.abs(c1_it) - np.abs(c2_it)) / np.sqrt(N)\n        b = (np.abs(c1_it) + np.abs(c2_it)) / np.sqrt(N)\n        theta = (np.angle(c1_it) + np.angle(c2_it)) / 2\n        ellipse_pts = [ellipse(a, b, phi, theta) for phi in np.linspace(0, 2*np.pi, 50)]\n\n        show_points(ellipse_pts, labels=False, dots=False, ax=ax, linewidth=2)\n\n        # for next iteration, do smoothing\n        points = do_smoothing(points, steps)\n        \nshow_iteration_vs_dominantEigenstates()\n\n\n\n\nWe see, how the dominant eigenstates start to fully describe the evolution."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#enforcement-of-circular-convergence",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#enforcement-of-circular-convergence",
    "title": "Polygon Smoothing Riddle",
    "section": "Enforcement of Circular Convergence",
    "text": "Enforcement of Circular Convergence\nComparison before and after “Face-lifting”:\n\ninit_points = np.random.standard_normal(N) + np.random.standard_normal(N)*1j\n\ninit_points_facelifted = init_points - dot(init_points, eigenstate1) * eigenstate1 \n# eigenstate1 is hereby fully removed, only eigenstate2 and the other contributions survive\n\nshow_points(init_points, plt.subplot(121))\nshow_points(init_points_facelifted, plt.subplot(122))\n\n\n\n\nLet it roll…\n\nsteps = 4 # steps between plots\n\npoints = init_points_facelifted\n\nplt.figure(figsize=[10,10]) \nfor i in range(16):\n    ax = plt.subplot(4,4,i+1)\n    show_points(points, ax)\n    points = do_smoothing(points, steps)\n\n\n\n\nAmazingly, here you have your ordered circle.\nHomework Exercise: How about a counter-clockwise arrangement? :-)\n\nAnswer to Question 3\nWe can conclude, that the following must be given in order to converge into a circle: Only clockwiseness or only counter-clockwiseness must be included in your start polygon, then it will evolve into a circle. While these terms are not well established in the community yet, we are confident that our work will have its impact here."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#conclusions-and-acknowledgments",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#conclusions-and-acknowledgments",
    "title": "Polygon Smoothing Riddle",
    "section": "Conclusions and Acknowledgments",
    "text": "Conclusions and Acknowledgments\nDear reader, thank you for your appreciated attention!\nWith that we would like to thank for all inspirational inputs from our “physicist” friends!\nYours sincerly, L. and M."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#shift-invariance",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#shift-invariance",
    "title": "Polygon Smoothing Riddle",
    "section": "Shift Invariance",
    "text": "Shift Invariance\nIf we go on step further in analysis, we can readily observe that we not only have a linear operation, but a translation invariant: If we shift the indizes of the point of input state, the smoothing process \\(\\mathbb S\\) will yield the same output as before, but with this output after the index shift. Index shift denoted by \\(\\mathcal R\\) and smoothing operation \\(\\mathbb S\\) commute:\n\\[ \\vec x = (x_1, x_2, ... x_N), \\, \\mathcal R\\,\\vec x = \\vec x' = (x_2, x_3, ... x_N, x_1):  \\quad \\mathcal R (\\mathbb S\\,\\vec x) =  \\mathbb S (\\mathcal R \\,\\vec x) = \\frac 1 2 (x_2+x_3, x_3+x_4, ...)\\]\nA general shift-invariant linear operation on continous functions are given by convolutions \\[ (f \\ast g)(x) \\doteq \\int \\,dy\\, g(y)\\,f(x-y) = h(x), \\quad f(x+\\Delta x) \\ast g(x) = h'(x) = h(x+\\Delta x)\\]\nThe convolution Fourier theorem tells us, that their corresponding Fourier transforms \\(f(x) = \\int\\,dk\\, \\tilde{f}(k)\\, \\exp(ikx)\\), …, are related by a simple multiplication\n\\[ \\tilde{f}(k) \\, \\tilde{g}(k) = \\tilde{h}(k) \\]\nThis is an interesting fact and allows to write a convolution in much simpler terms. Let’s try to apply this to our case."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#discrete-fourier-transforms-dft-theory",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#discrete-fourier-transforms-dft-theory",
    "title": "Polygon Smoothing Riddle",
    "section": "Discrete Fourier Transforms (DFT) Theory",
    "text": "Discrete Fourier Transforms (DFT) Theory\nAs phycisists, we are well experienced with the continous Fourier transform. But we obviously dont have an continous function but discrete points \\((x_1, x_2, ... x_n)\\). Here is a short intro to the discret case. DFT is a very common tool in digital signal processing where the signal is sampled at a fixed frequency…\n\nDiscretness\nLet’s define \\(f(d), d \\in \\mathbb Z\\). This simplifies the Fourier transform to\n\\[f(d) = \\int^{2\\pi}_{0}dk\\, \\tilde{f}(k)\\, \\exp(ikd)\\]\nIntuition: The wavevector spectrum is limited to \\(0...2\\pi\\). Any oscillation faster than “one oscillation per 1 unit” is not needed, as we only evalute \\(f(d)\\) at integer \\(d\\). (This result is known as Nyquist-Shannon theorem and can be gained in a more formal way by multiplying a general \\(f(x)\\) with a Dirac comb which results in the mentioned consequences in wavevector spectrum).\n\n\nFiniteness\nThe above results still assumed an umlimited number of points involved. Without loss of generality, we can define \\(f(d)\\) periodic, such that \\(f(d) = f(d+N)\\) holds. We limit the function to \\(N\\) different values. In general, a periodic function, like the newly defined \\(f(d)\\), can be represented with a discrete Fourier series\n\\[ f(x) = \\sum_{k=-\\inf}^{\\inf}\\, a(k) \\, e^{i\\frac{2\\pi k}{N} x}, \\quad a(k) \\in \\mathbb C .\\]\nIntuition: Only wavevectors with wavelenghts = repetion cycles which are integer fractions of the function cycle length \\(N\\), i.e. cycles which repeat after length \\(N\\), are present.\n\n\nDiscrete and Finite -&gt; DFT\nTaking both results, we ariive at the conclusion, that\n\\[ f(d) = \\sum_{k=0}^{N-1}\\, a(k) \\, e^{i\\frac{2\\pi k}{N} d} \\]\nwhere the coefficients \\(a(k) = \\tilde{f}(k), \\, k \\in \\{0, \\ldots, N-1\\}\\) are the discrete Fourier transform of \\(f(d)\\).\nWe can explicitly calculate for two summands\n\\[ \\sum_{d=0}^{N-1}  e^{i\\frac{2\\pi k}{N} d}  e^{-i\\frac{2\\pi k'}{N} d} = N \\delta_{k-k'} \\]\nand thereby observe the orthogonality of different terms which is well known in the continous case (where a Dirac delta function is used).\n\n\nDiscrete Convolution\nIn analogy to the continous case, a discrete, cylic convolution can be defined by\n\\[ (f \\ast g) (d) = \\sum_{d'=0}^{N-1} g(d') f(d-d') \\]\nwhere we assumed \\(f(d)\\) to be periodic. By explicitly calculating, we find \\[ (f \\ast g) (d)  = \\sum_{d'=0}^{N-1} \\left(\\sum_{k=0}^{N-1}\\, \\tilde g(k) \\, e^{i\\frac{2\\pi k}{N} d'}\\right) \\left(\\sum_{k'=0}^{N-1}\\, \\tilde f(k') \\, e^{i\\frac{2\\pi k'}{N} (d-d')}\\right)\n= \\sum_{k=0}^{N-1} \\sum_{k'=0}^{N-1}\\, \\tilde g(k) \\, \\tilde f(k') \\, \\sum_{d'=0}^{N-1} e^{i\\frac{2\\pi k}{N} d'} e^{i\\frac{2\\pi k'}{N} (d-d')} \\]\nEvaluating the sum over \\(d'\\) and using the orthogonality condition found above, we find a \\(N\\delta_{k-k'}\\) and therefore\n\\[ (f \\ast g) (d)  = N\\,\\sum_{k=0}^{N-1} \\tilde g(k) \\, \\tilde f(k) \\, e^{i\\frac{2\\pi k}{N} d} .\\]\nThis is the equivalent result to the continous case: The convolution is a mutliplication in Fourier space."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#polygon-smoothing-as-discrete-convolution",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#polygon-smoothing-as-discrete-convolution",
    "title": "Polygon Smoothing Riddle",
    "section": "Polygon Smoothing as Discrete Convolution",
    "text": "Polygon Smoothing as Discrete Convolution\nIf we chose\n\\[ f(d)  \\doteq x_{d-1}, \\, d \\in {0, \\ldots, N-1}, \\quad  g(0)= g(1) \\doteq \\frac 1 2, \\, g(d) \\doteq 0, \\, d \\in \\{2,\\ldots, N\\}\\]\nand furthermore impose periodicity with \\(f(d+N) = f(d)\\), equally on \\(g(d)\\), both function are defined over \\(\\mathbb Z\\), but represent \\(N\\) independent complex points. With and the above defined discrete convolution, we find\n\\[ (f \\ast g) (d) = \\sum_{d'=0}^{N-1} g(d') f(d-d') = h(d) = \\frac{x_d+x_{d-1}} 2 \\]\nWe observe that this corresponds to our smoothing/averaging process \\(\\mathbb S\\)! It is a moving averaging operation performed on the set of points.\nThe Fourier convolution theorem tells us, that this linear, shift-invariant operation can be written in this discrete case with the transforms\n\\[ \\tilde{h}(k) = N \\tilde{f}(k)\\,\\tilde{g}(k), \\, k \\in \\{0,N-1\\}\\]\nIf we iterate \\(G\\) times through the smooting, we arrive at the simple result \\[ \\tilde{h}(k) = \\tilde{f}(k)\\,(N\\tilde{g}(k))^{G}\\]\nThis fully determines the evolution. If \\(N|\\tilde g(k)|&lt;1\\), the components at given \\(k\\) are increasingly suppressed. With this, we got all eigenstates of the smoothign operation for free: They are apparatly the Fourier components of different \\(k\\)."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#numeric-illustration",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#numeric-illustration",
    "title": "Polygon Smoothing Riddle",
    "section": "Numeric Illustration",
    "text": "Numeric Illustration\n\nN = 13\ninitial_points = np.random.standard_normal(N) + np.random.standard_normal(N)*1j\nf = initial_points\n\nLet’s generate to above defined \\(g(d)\\) with\n\ng = np.zeros(N)\ng[[0,1]] = 1/2\nprint(g)\n\n[0.5 0.5 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0. ]\n\n\nLet Python calculate the DFT, as defined above, using FFT functions\n\nf_tilde = np.fft.ifft(f)\ng_tilde = np.fft.ifft(g)\n\nThe smoothing iteration using the convolution theorem is illustrated here togehter with the Fourier transform:\n\nsteps_per_image = 10\nn = 5\n\nplt.figure(figsize=[25,5]) \nfor i in range(n):\n    \n    h_tilde = np.multiply(f_tilde, np.power(N*abs(g_tilde), i*steps_per_image)) # according to convolution fourier theorem, see above\n    h = np.fft.fft(h_tilde)\n\n    ax = plt.subplot(2,n,i+1)\n    ax.set_title(\"$\\\\tilde h(k)$\")\n    ax.bar(range(N),abs(h_tilde))\n    \n    ax = plt.subplot(2,n,i+n+1)\n    ax.set_title(\"$f(d)$\")\n    show_points(h, ax=ax)  \n\n\n\n\nThings seemt to work out\n\nInterpretation\nAs abovious from the multiplication factor \\(\\tilde g(k)\\):\n\nplt.plot(N*abs(g_tilde))\n\n\n\n\noscillations \\(k=0, 1\\) and \\(N-1\\) are dominant. All other are suppressed stronger and damped out in the iteration shown above.\nAs can be seen in the DFT defition, \\(k=0\\) corresponds to a constant, which here represents the center of gravity of the points which does not change through iterations: \\(\\tilde g(0) = 1\\). \\(k=1\\) and \\(N-1\\) are the already known clockwise and counterclockwise circles. If added up in a linear combination, they result in an ellipse.\nAll the other Fourier terms are circles as well, but with winding number \\(W\\) larger than one. Just a few examples:\n\nplt.figure(figsize=[25,4]) \nws = range(-1,5)\nfor i, w in enumerate(ws):\n    ax = plt.subplot(1,len(ws), i+1)\n    ax.set_title(\"W = \" + str(w))\n    \n    a = np.zeros(N)\n    a[w % N] = 1\n    h = np.fft.ifft(a)\n    \n    print(a)\n    show_points(h, ax=ax)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]\n[1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\n\n\nInsofar, we have to correct our answer above: we arrive at pure circles of only winding number \\(W=1\\) or -1 are present, not both. But any higher wining number of any sign (clockwise or counter clockwise) will be damped away anyways.\nGeometrically, this is obvious: the more curved, the stronger diminished are the shapes in the smoothing process.\nWith that, we finally and ultimatley conclude :-)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Hello!\nYou might be here for the GPS walkthrough post series…"
  },
  {
    "objectID": "index.html#recent-posts",
    "href": "index.html#recent-posts",
    "title": "Welcome",
    "section": "Recent Posts",
    "text": "Recent Posts\n\n\n\n\n\n\n\n\nGPS Walkthrough – Series Introduction\n\n\n\nAug 15, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeodesics on Curved Surfaces\n\n\n\nApr 15, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nPolygon Smoothing Riddle\n\n\n\nApr 27, 2020\n\n\n\n\n\n\n\n\nNo matching items\n\n\n All Posts"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Blog Posts",
    "section": "",
    "text": "GPS Walkthrough – Series Introduction\n\n\n\n\n\n\n\nGPS\n\n\nphysics\n\n\n\n\nA Journey from Radio Wave to Position Fix…\n\n\n\n\n\n\nAug 15, 2023\n\n\nManuel\n\n\n\n\n\n\n  \n\n\n\n\nGeodesics on Curved Surfaces\n\n\n\n\n\n\n\nmath\n\n\n\n\nWe investigate geodesics on parametrized curved surfaces which are embedded in 3D space. Visualization and computation is implemented in Python.\n\n\n\n\n\n\nApr 15, 2022\n\n\nManuel\n\n\n\n\n\n\n  \n\n\n\n\nPolygon Smoothing Riddle\n\n\n\n\n\n\n\nmath\n\n\nriddles\n\n\n\n\nWe analyze a geometrical phenomenon appearing in an averaging procedure performed on polygons. Linear algebra and Fourier analysis methods give insights into the mechanism.\n\n\n\n\n\n\nApr 27, 2020\n\n\nManuel and Laura\n\n\n\n\n\n\nNo matching items"
  }
]