[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! My name is Manuel and I am living in Switzerland. I have graduated in physics and currently I am working in IT. In this blog, I occasionally write about my hobby projects. Usually, you can expect to read about riddles, physics, electronics, math or computer science.\nIn case you are wondering about the nickname as well: Probably it’s just some greek letters and math related sequences 😀\nIf you like my article and you want to support me:\n\n\n\n\nThis website is built using the amazing Quarto publishing system. Its source code can be found here."
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html",
    "title": "Geodesics on Curved Surfaces",
    "section": "",
    "text": "In this post, I try to find and illustrate geodesics on 2-D curved surfaces that are embedded in 3-D space. Due to a specific question from a friend of mine, the main goal is to find closed geodesics on a Möbius strip.\nA geodesic is a curve in the surface with no transversal acceleration, i.e. a straight line. E.g. the shortest path between two points is a geodesic. Any path connecting the two points is a geodesic, if and only if a rope, which is aligned along this curve on the surface, does not change its shape under tension.\nWe follow the definitions and formalism in https://de.wikipedia.org/wiki/Christoffelsymbole. We assume to have a parametrization of the curved surface which embed them into 3-D euclidean space by the function \\[X:  (u,v) \\rightarrow (x,y,z) \\in \\mathbb R^3.\\]\nChristoffel symbols \\(\\Gamma^a_{bc}\\) can be calculated with the identities \\[\\begin{align}\n\\frac{\\partial^2 X}{\\partial u^2} &= \\Gamma^1_{11} \\frac{\\partial X}{\\partial u} + \\Gamma^2_{11}\\frac{\\partial X}{\\partial v} + h_{11} N\\,,\\\\[0.5em]\n\\frac{\\partial^2 X}{\\partial u \\partial v} &= \\Gamma^1_{12} \\frac{\\partial X}{\\partial u} + \\Gamma^2_{12}\\frac{\\partial X}{\\partial v} + h_{12} N\\,,\\\\[0.5em]\n\\frac{\\partial^2 X}{\\partial v \\partial u} &= \\Gamma^1_{21} \\frac{\\partial X}{\\partial u} + \\Gamma^2_{21}\\frac{\\partial X}{\\partial v} + h_{21} N\\,,\\\\[0.5em]\n\\frac{\\partial^2 X}{\\partial v^2} &= \\Gamma^1_{22} \\frac{\\partial X}{\\partial u} + \\Gamma^2_{22}\\frac{\\partial X}{\\partial v} + h_{22} N\\,.\n\\end{align}\\]\nGiven a curve \\(\\gamma(t) = X(u(t), v(t))\\) on the surface, and using the definition \\(u_1=u\\) and \\(u_2=v\\), the tangential (in-plane) acceleration can be writen as \\[(\\ddot\\gamma)^\\top = \\left(\\ddot u_1 + \\sum_{i,j = 1}^2 \\Gamma^1_{ij} \\dot u_i \\dot u_j \\right)\\frac{\\partial X}{\\partial u_1} + \\left(\\ddot u_2 + \\sum_{i,j=1}^2 \\Gamma^2_{ij} \\dot u_i \\dot u_j \\right)\\frac{\\partial X}{\\partial u_2}.\\] For a geodesic, we expect this to acceleration vanish. Therefore \\[\\ddot u_k + \\sum_{i,j = 1}^2 \\Gamma^k_{ij} \\dot u_i \\dot u_j  = 0, \\quad \\text{for } k=1,2. \\] This differential equation of the curves parameters \\(u(t), v(t)\\) can be solved to find a geodesic curve.\nIn the follwing implementation, a semi-analytic approach is chosen: The surface parametrization and its derivates are symbolically treated, the evaluation of Christoffel symbols and solving of the geodaetic differential equation is performed numerically. This is in our view the most flexibel and robust way, as it doesn’t require inversion of analytic functions."
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#helper-functions",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#helper-functions",
    "title": "Geodesics on Curved Surfaces",
    "section": "Helper Functions",
    "text": "Helper Functions\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport scipy.integrate\nimport scipy.optimize\n\nfrom sympy import sin, cos, symbols, lambdify, Matrix, vector\n\n\ndef plot_surface(surface, line=None):\n    fig = plt.figure(figsize=(13,13))\n    ax = fig.add_subplot(projection='3d')\n    \n    surface = (np.squeeze(c) for c in surface) # unpack the coordinates X,Y,Z \n    ax.plot_wireframe(*surface, alpha=0.2)\n    \n    ax.set_box_aspect([ub - lb for lb, ub in (getattr(ax, f'get_{a}lim')() for a in 'xyz')])\n    \n    if line is not None: \n        line = (np.squeeze(c) for c in line)\n        ax.plot(*line, color='red', linewidth=5)\n    return ax\n\n\ndef geodesic(X, u_symbol, v_symbol, y0, tmax=10, solver_event=None):\n    \"\"\"Solve the geodesic equation given the surface X and return the curves parameters.\"\"\"\n    \n    def Christoffel_Gamma(u, v):\n        \"\"\"calculates the Christoffel symbol value at point (u,v). Needs first- and \n        second-order derivatives of euclidean X coordantes (x,y,z) with respect to the \n        plane parameters / inner coordinates (u,v)\"\"\"\n\n        # second derivates\n        dX_du2 = dX_du2_num(u, v)\n        dX_dv2 = dX_dv2_num(u, v)\n        dX_dudv = dX_dudv_num(u, v)\n\n        # first-order derivates and normal vector matrix\n        dX_du = dX_du_num(u, v)\n        dX_dv = dX_dv_num(u, v)\n        N = np.cross(dX_du, dX_dv, axis=0) # normal vector\n        dX_matrix = np.hstack([dX_du, dX_dv, N]) \n\n        # express second-order derivative in first-derivatives -&gt; Christoffel symbol\n        gamma_uu = np.linalg.solve(dX_matrix, dX_du2)[0:2]  # = \\Gamma^k_uu, k=u or v\n        gamma_uv = np.linalg.solve(dX_matrix, dX_dudv)[0:2] # = \\Gamma^k_uv, k=u or v\n        gamma_vv = np.linalg.solve(dX_matrix, dX_dv2)[0:2]  # = \\Gamma^k_vv, k=u or v\n\n        return (gamma_uu, gamma_uv, gamma_vv)\n\n    \n    def geodesic_equation(t, y):\n        \"\"\"Implements geodesic equation for ODE solver. Second-order eqn. are mapped to \n        system of first-order differential equations:  dy/dt = geodesic_eqn(t, y)\n\n        t: parameter of line\n        y:  = (u, u', v, v') with plane coordinates (u,v) and their derivatves\n        \"\"\"\n\n        u, dudt, v, dvdt = y # state variables\n\n        gamma_uu, gamma_uv, gamma_vv = Christoffel_Gamma(u, v)\n\n        # Geodesic equation, see [https://de.wikipedia.org/wiki/Christoffelsymbole]:\n        #  $$ u_k'' = -  \\sum_ij gamma^k_ij * u'_i * u'_j  for all k $$\n        # we use coordinates (u,v), these map to u_k with:  u_1 = u, u_2 = v\n\n        du_dt2 = -(gamma_uu * dudt**2 + 2 * gamma_uv * dudt * dvdt + gamma_vv * dvdt**2)\n\n        # return vector with derivatives (u', u'', v', v'')\n        derivates =  np.array([dudt, du_dt2[0,0], dvdt, du_dt2[1,0]])\n        return derivates\n\n    \n    u = u_symbol\n    v = v_symbol \n    \n    # symbolic first- and second-order derivatives\n    dX_du = X.diff(u)\n    dX_dv = X.diff(v)\n    dX_du2 = X.diff(u,u)\n    dX_dudv = X.diff(u, v)\n    dX_dv2 = X.diff(v, v)\n\n    # ... and their numerical functions\n    X_num = lambdify((u, v), X, 'numpy')\n    dX_du_num = lambdify((u, v), dX_du, 'numpy')\n    dX_dv_num = lambdify((u, v), dX_dv, 'numpy')\n    dX_du2_num = lambdify((u, v), dX_du2, 'numpy')\n    dX_dudv_num = lambdify((u, v), dX_dudv, 'numpy')\n    dX_dv2_num = lambdify((u, v), dX_dv2, 'numpy')\n        \n    sol = scipy.integrate.solve_ivp(geodesic_equation, [0, tmax], y0, dense_output=True,\n                                    events=solver_event)\n    \n    # return the solver object if events were provided, otherwise only return function\n    if solver_event:\n        return sol\n    else:\n        return lambda t: sol.sol(t)[[0,2]]  # return u and v coordinate tuple only"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#flat-plane-in-polar-coordinates",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#flat-plane-in-polar-coordinates",
    "title": "Geodesics on Curved Surfaces",
    "section": "Flat Plane in Polar Coordinates",
    "text": "Flat Plane in Polar Coordinates\nTest the geodesics calculation on a flat surface defined with polar coordinates. We expect straight line :)\n\nu, v = symbols('u v') # u = radius, v = angle phi\n\n# Express euclidean coordinates (x,y,z) in terms of plane parameters (u,v)\nX = Matrix([u * cos(v), \n            u * sin(v), \n            u * (cos(v) + sin(v))])\n\n# first-order derivatives\ndX_du = X.diff(u)\ndX_dv = X.diff(v)\n\n# ... and their numerical functions\nX_num = lambdify((u, v), X, 'numpy')\ndX_du_num = lambdify((u, v), dX_du, 'numpy')\ndX_dv_num = lambdify((u, v), dX_dv, 'numpy')\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}u \\cos{\\left(v \\right)}\\\\u \\sin{\\left(v \\right)}\\\\u \\left(\\sin{\\left(v \\right)} + \\cos{\\left(v \\right)}\\right)\\end{matrix}\\right]\\)\n\n\nJust for fun, show plane, a curve and the phi and r coordinate basis vectors:\n\n# calculate surface points for certain coordinate range\nu_grid, v_grid = np.meshgrid(np.linspace(0, 1, 100), \n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nline = X_num(0.5, np.linspace(0, 2*np.pi, 100)) # define arbitrary line\n\n# show the basis vector for the local tangent plane at some points\nu_grid, v_grid = np.meshgrid(np.linspace(0, 1, 5), \n                             np.linspace(0, 2*np.pi, 20))\npoints = X_num(u_grid, v_grid)\nvec = dX_du_num(u_grid, v_grid) /10\nvec2 = dX_dv_num(u_grid, v_grid) /10\n\nax = plot_surface(surface, line)\nax.quiver3D(*(c for c in points), *(v for v in vec), color='green')\nax.quiver3D(*(c for c in points), *(v for v in vec2), color='red');\n\n\n\n\nFor sure, the red line is not a geodesic, so let’s try to turn on the machinery…\n\n# solve the geodesic equation:\ntmax = 3             # maximum length of line\ny0 = [.5, -.5, 0, 1] # initial coordinates and derivatives (u, u', v, v'), determines direction and starting point\ng = geodesic(X, u, v, y0, tmax)\n\n# show it\nt = np.linspace(0,tmax,100)\nplot_surface(surface, X_num(g(t)[0], g(t)[1]));\n\n\n\n\nIt looks like we have a straight line, ie. a geodesic in the flat plane! :-D\nLet’s have a look at the (u,v) coordinates of the geodesic. After all, they probably look more interesting…\n\nfig = plt.figure(figsize=(10, 6))\nax = fig.add_subplot()\nax.plot(g(t)[0], g(t)[1])\nax.set_xlabel('r')\nax.set_ylabel('phi')\nplt.title('Geodesic on Flat Plane in Polar Coordinates');"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#sphere",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#sphere",
    "title": "Geodesics on Curved Surfaces",
    "section": "Sphere",
    "text": "Sphere\n\nu, v = symbols('u v') # u = phi, v = angle theta\n\n# Euclidean Mapping (u,v) -&gt; (x,y,z)\nR0 = 1\nX = Matrix([R0 * cos(u)*sin(v), \n            R0 * sin(u)*sin(v), \n            R0 * cos(v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points for certain coordinate range\nu_grid, v_grid = np.meshgrid(np.linspace(0, 2*np.pi, 100), \n                             np.linspace(0, np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\n\ntmax = 10                  # maximum length of line\ny0 = [1, 1, np.pi/2+.7, 0] # initial  u, u', v, v', determines direction and starting point\ng = geodesic(X, u, v, y0, tmax)\n\n# show it\nt = np.linspace(0, tmax, 100)\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nLooks like a great circle, i.e. a geodesic. Check!"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#torus",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#torus",
    "title": "Geodesics on Curved Surfaces",
    "section": "Torus",
    "text": "Torus\n\nu, v = symbols('u v')\nR0, R1 = 1, 0.25\nX = Matrix([R0 * cos(u) + R1 * cos(u) * cos(v), \n            R0 * sin(u) + R1 * sin(u) * cos(v),\n            R1 * sin(v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(0, 2*np.pi, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\n\n%matplotlib inline\n\ntmax = 7\ny0 = [0, 0, 0, 1] # point towards v coordinate\ng = geodesic(X, u, v, y0, tmax)\n\nt = np.linspace(0, tmax, 100)\nax = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n# a different geodesic:  point towards u coordinate only\ny0 = [0, 1, 0, 0] \ng = geodesic(X, u, v, y0, tmax)\n\nline = X_num(g(t)[0], g(t)[1])\nline = (np.squeeze(c) for c in line)\nax.plot(*line, color='red', linewidth=5)\n\n# a third geodesic: inclined in both parameters\ny0 = [0, .1, 0, 1]\ntmax=35\ng = geodesic(X, u, v, y0, tmax)\n\nt = np.linspace(0, tmax, 300)\nline = X_num(g(t)[0], g(t)[1])\nline = (np.squeeze(c) for c in line)\nax.plot(*line, color='green', linewidth=5)\n\n[&lt;mpl_toolkits.mplot3d.art3d.Line3D at 0x7f625415bbe0&gt;]\n\n\n\n\n\nLooks like geodesics one would expect… Check! And now to the serious stuff:"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#cone",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#cone",
    "title": "Geodesics on Curved Surfaces",
    "section": "Cone",
    "text": "Cone\nTODO, might look nice…"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#möbius-strip",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#möbius-strip",
    "title": "Geodesics on Curved Surfaces",
    "section": "Möbius Strip",
    "text": "Möbius Strip\n\nu, v = symbols('u v')\n\nR = 1\nX = Matrix([(R + u * cos(0.5 * v)) * cos(v),\n            (R + u * cos(0.5 * v)) * sin(v),\n            u * sin(0.5 * v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(-1, 1, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}\\left(u \\cos{\\left(0.5 v \\right)} + 1\\right) \\cos{\\left(v \\right)}\\\\\\left(u \\cos{\\left(0.5 v \\right)} + 1\\right) \\sin{\\left(v \\right)}\\\\u \\sin{\\left(0.5 v \\right)}\\end{matrix}\\right]\\)\n\n\n\nClosed Loop Geodesic\nWe don’t want to find any geodesic, but a closed one. Therefore we need some preparations. Starting the geodesic at a point (u,v), we need to find the good direction to shoot if off, in order to hit the same point after roundtrip again:\n\ntmax = 5      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = 0   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target = - u_start          # Möbius strip: u -&gt; -u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\n\ndef closed_loop_metric(du_dt):\n    \"\"\"Returns a measure of how good we got a closed loop given a du/dt starting direction.\"\"\"\n    \n    def u_crossing_event(t, y):\n        \"\"\"Used in scipy.integrate.solve_ivp(event=) of geodesics() function, \n        used to detect target u values -&gt; potential closed loop.\"\"\"\n        return (y[0] - u_end_target) \n   \n    y0 = [u_start, du_dt, v_start, 1]  # fixed dv/dt=1 in order to go along strip\n    g = geodesic(X, u, v, y0 , tmax, solver_event=u_crossing_event)\n    \n    #print(g.y_events)\n    if len(g.y_events[0]) == 0:\n        return 100\n    \n    # find v in events of u_end_target crossings, which is closest to v_end_target\n    closest_idx = np.argmin(abs(g.y_events[0][:, 2] - v_end_target))\n    u_end, v_end = g.y_events[0][closest_idx, [0,2]]\n                            \n    return (u_end_target - u_end)**2 + (v_end_target - v_end)**2\n\nWith that, we can searching optimal du/dt direction. (Set some starting point in the neighbourhood, which can be ound by studying geodesic (u,v) plots manually)\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[-.7, -.8])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 1.858207977514734e-14\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 23\n     nit: 18\n success: True\n       x: -1.5117115896978943\n\n\nLet’s have a look at this curve with the found du/dt value:\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\n%matplotlib inline\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nWhile we arrived at the same starting pint, the geodesics cuts itself at an angle and is not closed.\n\n\nClosed Geodesics, Take II\nExperimenting with the initial values showed that (u,v)=(0,\\(\\pi\\)) might yield better results:\n\ntmax = 5      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target = - u_start          # Möbius strip: u -&gt; -u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction. ( See Experiments section below for chosen starting points 0.5, 0.51)\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.5, 0.51])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 4.479991192779563e-13\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 25\n     nit: 17\n success: True\n       x: 0.6641064541349162\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nHere we arrived at a properly closed geodesic on the Möbius strip. Other starting value for u_start might yield others as well."
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#triple-twisted-strip",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#triple-twisted-strip",
    "title": "Geodesics on Curved Surfaces",
    "section": "Triple Twisted Strip",
    "text": "Triple Twisted Strip\nThree times twisted strip\n\nu, v = symbols('u v')\n\nR = 1\nX = Matrix([(R + u * cos(1.5 * v)) * cos(v),\n            (R + u * cos(1.5 * v)) * sin(v),\n            u * sin(1.5 * v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(-.5, .5, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}\\left(u \\cos{\\left(1.5 v \\right)} + 1\\right) \\cos{\\left(v \\right)}\\\\\\left(u \\cos{\\left(1.5 v \\right)} + 1\\right) \\sin{\\left(v \\right)}\\\\u \\sin{\\left(1.5 v \\right)}\\end{matrix}\\right]\\)\n\n\nSearch a closed geodesic:\n\ntmax = 6    # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi/2/1.5   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target =  - u_start         # Möbius strip: u -&gt; u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction.\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.2, 0.3])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 7.121210237517629e-11\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 34\n     nit: 30\n success: True\n       x: 0.31788575631551347\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nWe successfully arrived at the closed geodesics! let’s export the data:"
  },
  {
    "objectID": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#doubly-twisted-strip",
    "href": "posts/geodesics/Geodesics_on_Curved_Surfaces.html#doubly-twisted-strip",
    "title": "Geodesics on Curved Surfaces",
    "section": "Doubly Twisted Strip",
    "text": "Doubly Twisted Strip\n\nu, v = symbols('u v')\n\nR = 1\nX = Matrix([(R + u * cos(1 * v)) * cos(v),\n            (R + u * cos(1 * v)) * sin(v),\n            u * sin(1 * v)])\n\nX_num = lambdify((u, v), X, 'numpy')\n\n# calculate surface points\nu_grid, v_grid = np.meshgrid(np.linspace(-.5, .5, 100),\n                             np.linspace(0, 2*np.pi, 100))\nsurface = X_num(u_grid, v_grid)\n\nX\n\n\\(\\displaystyle \\left[\\begin{matrix}\\left(u \\cos{\\left(v \\right)} + 1\\right) \\cos{\\left(v \\right)}\\\\\\left(u \\cos{\\left(v \\right)} + 1\\right) \\sin{\\left(v \\right)}\\\\u \\sin{\\left(v \\right)}\\end{matrix}\\right]\\)\n\n\n\nClosed Geodesic - Take I\n\ntmax = 6      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target =  u_start          # non-Möbius strip: u -&gt; u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction.\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.5, 0.51])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 1.9317193557273604e-12\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 24\n     nit: 17\n success: True\n       x: 0.5568187609997342\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\nThese (u,v) coordinates show that we dont have a closed geodesic. New try…\n\n\nClosed Geodesic - Take II\n\ntmax = 6      # max t parameter = max geodesic length\nu_start = 0   # starting point u\nv_start = np.pi/2   #   ... and  v\n\n# define end coordinates which correspond to a closed loop\nu_end_target =  u_start          # non-Möbius strip: u -&gt; u after one turn\nv_end_target = v_start + 2*np.pi  # one single turn\n\nSearch optimal direction.\n\nminimizer = scipy.optimize.minimize_scalar(closed_loop_metric, bracket=[0.3, .31])\nprint(minimizer)\ndu_dt_closedloop = minimizer.x\n\n     fun: 1.1346961251873202e-13\n message: '\\nOptimization terminated successfully;\\nThe returned value satisfies the termination criteria\\n(using xtol = 1.48e-08 )'\n    nfev: 25\n     nit: 18\n success: True\n       x: 0.4467328464205437\n\n\n\ny0 = [u_start, du_dt_closedloop, v_start, 1]  # as defined in closed_loop_metric()\ng = geodesic(X, u, v, y0, tmax)\n\n\nfig = plt.figure()\nax = fig.add_subplot()\nax.set_xlabel('v')\nax.set_ylabel('u')\n\n# start and end point\nax.plot([v_start, v_end_target], [u_start, u_end_target], 'o', color='red')\n\nt = np.linspace(0, tmax, 100)\nline = (g(t)[1], g(t)[0])\nax.plot(*line);\n\n\n\n\n\n_ = plot_surface(surface, X_num(g(t)[0], g(t)[1]))\n\n\n\n\nWe successfully arrived at a closed geodesic on the doubly twisted strip!"
  },
  {
    "objectID": "posts/gps/index.html",
    "href": "posts/gps/index.html",
    "title": "GPS Walkthrough Series",
    "section": "",
    "text": "See also the series repository for source files.\n\n\n\n\n\n\n\n\n  \n\n\n\n\nGPS Walkthrough – A Journey from Radio Wave to Position Fix\n\n\n\n\n\nThis post series will guide you to through the calculation of a position fix from a recorded GPS radio wave signal. In this introduction, the motivation, goals and steps to follow are presented.\n\n\n\n\n\n\nAug 11, 2023\n\n\nManuel\n\n\n\n\n\n\n  \n\n\n\n\nGPS Walkthrough 1 — Overview\n\n\n\n\n\nThis post gives an overview of all steps involved in the GPS walkthrough, with all main results but lacking the detailed explanations of later steps.\n\n\n\n\n\n\nDec 10, 2023\n\n\nManuel\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/gps/step1_overview.html",
    "href": "posts/gps/step1_overview.html",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "",
    "text": "This article is step 1 of the GPS walkthrough series. Here we give an overview over the whole post series and introduce every step required to get from a raw GPS signal to a position fix. The main results are shown while detailed analysis and explanations are following in later posts."
  },
  {
    "objectID": "posts/gps/step1_overview.html#introduction",
    "href": "posts/gps/step1_overview.html#introduction",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "1 Introduction",
    "text": "1 Introduction\nIn this post series we investigate the GPS L1 C/A, the legacy signal with its coarse acquisition code sent by all GPS satellites in operation.\nWe will rely in the following to an external python module developed for this series, the gps_walkthrough module. Open the collapsed code sections below to get to know how it is used an how its outputs are processed. Check the module source code if you want deeper insights into the details of the processing steps before the more detailed blog articles appear. See also the references section below for a list of sources where I have the information collected from.\nTo compute the following steps for yourself online, open it in Google Colab. You can even feed it your own recorded GPS radio wave to play with the satellite signal and determine your location.\nNow enjoy the journey!\n\n\nCode\nimport gps_walkthrough as gpswt  # see https://github.com/mu2718/gps-walkthrough/\n\n# the only other packages we will rely on:\nimport numpy as np\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "posts/gps/step1_overview.html#recording-radio-wave",
    "href": "posts/gps/step1_overview.html#recording-radio-wave",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "2 Recording Radio Wave",
    "text": "2 Recording Radio Wave\nAn active GPS antenna picks up the electromagnetic (EM) wave sent by a satellite (or ‘space vehicle’ in GPS lingo) and feeds it to an integrated signal amplifier and filter. Its output signal is directly proportional to the incoming EM wave at any time. This output is wired up with a software-defined radio (SDR) receiver. This device is able to select a frequency-band and digitize it. Using this setup, we get an unprocessed, digital representation of the incoming GPS signal.\nI am using the HackRF SDR, a signal generator from Siglent delivering a high-accuracy clock to the SDR, and the u-blox ANN-MB GPS antenna.\n\n\n\n\n\n\nAnalyze your own GPS radio wave?\n\n\n\n\n\nFor recording the GPS radio wave, have the following equipment ready:\n\nSDR receiver (e.g. HackRF or RTL-based) capable to receive at 1575 MHz. No precise clock reference as I use here is required.\nActive GPS antenna for the L1 band with at least 20dB gain. A cheap 10$ one is sufficient (e.g. MikroTik ACGPSA).\nBias tee voltage supply if the SDR does not support powering the antenna. This is not required for HackRF with antennas accepting 3.3 Volts.\n\nAlternatively, a synthetic recording can be generated using gps-sdr-sim.\nWait for the walkthrough step 2 to get more detailed instructions…\n\n\n\nWith the following command, the HackRF records the GPS L1 signal at 1575.42 MHz with appropriate settings for amplifiers and sampling rate of 4 MHz:\n$ hackrf_transfer -r wave.dat -f 1575420000 -p 1 -a 1 -l 40 -g 40 -s 4000000\nThe specified file contains the recorded, raw in-phase and quadrature components (IQ) of the EM wave amplitude. We can read in this wave file and visualize a snippet of it in Figure 1.\n\n\nCode\nsampling_rate = 4e6  # 4 MHz sampling rate of recording\n\n# read in the recorded radio wave file (change dtype='byte' for data from `hackrf_transfer`)\nbaseband = gpswt.SdrWave.from_raw_file('./wave.dat', sampling_rate=sampling_rate, \n                                       #, max_samples=100000000)  # limit samples for fast experiments\n                                       dtype='float32') \n# cut the first 0.1 seconds during antenna power up\nbaseband = baseband.get_interval(from_time=0.1)\nprint(f'Wave recording read. Duration: {baseband.duration():0.2f} s')\n\n# visualize a snippet \nt0 = 0.2   # select start time\ndt = 1e-3  # time window of 1ms\n\nsignal_slice = baseband.get_interval(from_time=t0, to_time=t0+dt)\nt = np.linspace(t0, t0+dt, len(signal_slice.samples))\n\nplt.figure(figsize=(10,2))\nplt.plot(t, np.real(signal_slice.samples),'-', label='In-Phase $I$')\nplt.plot(t, np.imag(signal_slice.samples),'-', label='Quadrature $Q$')\nplt.xlabel('Receiver Time $t$ [s]')\nplt.ylabel('Amplitude [a.u.]')\nplt.legend()\nplt.show()\n\n\nWave recording read. Duration: 84.26 s\n\n\n\n\n\nFigure 1: Snippet of 1 ms of the recorded radio wave baseband signal with its in-phase and quadrature amplitudes.\n\n\n\n\nIf you want to get more detailed instructions for recording the GPS signal, understand EM waves and SDRs, IQ components and how they can be processed using NumPy, wait for the walkthrough step 2 to get posted. In the meantime, have a look into the source code of the SdrWave class."
  },
  {
    "objectID": "posts/gps/step1_overview.html#signal-acquisition",
    "href": "posts/gps/step1_overview.html#signal-acquisition",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "3 Signal Acquisition",
    "text": "3 Signal Acquisition\nHaving the radio wave recorded, we can look for a satellite signal. Those of us having experience with pre-internet radio know: Tuning-in on a channel means essentially turning one knob to set the frequency right (and sometimes redirecting and stretching the antenna). GPS L1 C/A is not much different, but we have four knobs which have to be set, the demodulation parameters:\n\nFrequency Shift\n\nGPS L1 satellites send on a carrier frequency of 1575.42 MHz with very high accuracy. But due the satellites high speeds of up to 4000 m/s relative to us, the Doppler effect physically shifts the received frequency up to \\(\\pm 5000\\) Hz. Despite its relatively small magnitude, the Doppler shift has to be compensated for signal reception. Note that changes in velocity of the satellite relative to the receiver (e.g. in a fly-over) results in changes of this parameter over time and thereby need to be readjusted constantly.  An inaccurate receiver clock, i.e. the clock built into the SDR receiver, is an additional source of frequency shift: As we base all our measurement on it, a too slow clock will show up as too high frequencies in the recording and vice versa. Since I use an external high-accuracy clock, the frequency shift can be fully attributed to the Doppler effect in the following.\n\nPRN number (C/A Code)\n\nAll satellites send on the same frequency. Using a code-division multiple access (CDMA) method, where each satellite sends its own code, we can distinguish EM wave contributions from different senders. These code sequences are called C/A codes and are identified by their pseudo-random noise or PRN numbers, ranging from 1 to 37. The PRN number has therefore to be set to select a specific satellite to listen to.\n\nCode Delay\n\nThe C/A code sequence of a satellite can only be detected if we know its time of reception to within a microsecond. The code delay is defined by the time the code is sent, as expected based on the receiver’s own inaccurate clock, and the actually observed time of reception. Note that changes in distance between the receiver and a satellite modifies this value by 1 \\(\\mu s\\) per 300 meters distance. Since satellites travel at up to 4000 m/s, we need to constantly readjust the delay to maintain reception.\n\nCarrier Phase Angle\n\nGPS L1 satellites send telemetry data (GPS time, orbital parameters, …). It is transmitted in the EM wave using the binary phase-shift keying (BPSK) modulation technique. In order to demodulate this information, we need to distinguish between the sine and cosine contributions of the carrier frequency, i.e. the phase angle of the received wave. Note that changes in distance to a satellite or atmospheric conditions modify the phase over time.\n\n\nThe GPS signal acquisition procedure tries to find the value of these parameters for optimal signal reception by going through all combinations of parameters settings and picking the optimal one.\n\nFirst Signal Detection\nFor the very first millisecond of our radio wave recording, let’s try to find the signal sent by the satellite which emits the C/A code PRN 16 by performing the acquisition:\n\n\nCode\nacq = gpswt.Acquisition(prn_id=16, sampling_dt=baseband.sampling_dt)  # look for PRN 16, I know it is there :) \nacq_data = acq.search(baseband.get_interval(to_time=0.001),           # look at first 1 ms = 1 C/A code period\n                      delta_freq_range=(-5000, 5000),                 # increase to 100k for HackRF w/o external clock\n                      delta_freq_step=10)[-1]                         # fine-grained Doppler steps \n\nprint(f\"Signal Power:  {np.abs(acq_data['correlator'])**2 * 100:.2f} % of total\")\nprint(f\"Doppler Shift: {acq_data['delta_freq']} Hz\")\nprint(f\"Code Delay:    {acq_data['delay'] * 1e6} microseconds\")\nprint(f\"Carrier Phase: {np.angle(acq_data['correlator']):.2f} radians\")\n\n\nSignal Power:  1.69 % of total\nDoppler Shift: -2830.0 Hz\nCode Delay:    13.0 microseconds\nCarrier Phase: 1.04 radians\n\n\nThese are the optimal demodulation parameter settings the acquisition procedure has found. Some observations we can make already:\n\nDespite that the satellite’s signal power is below 2% of the total power that the SDR records, we can isolate it and distinguish it from noise and other satellites.\nA negative Doppler shift means that the received frequency is lower than it was sent by the satellite. As we know it from everyday acoustic experiences, we can infer that this satellite is heading away from us. We will confirm this later on.\n\nThe scanning on Doppler shift and code delay performed during acquisition is shown in Figure 2. We can observe that a discrepancy of only 1 \\(\\mu s\\) of in code delay and 1000 Hz in frequency shift results in total loss of the signal. This distinct signature of the peak indicates that our demodulation works and that we have detected a signal sent by a satellite!!\n\n\nCode\nplt.subplot()\nplt.imshow(acq._scan_data * 100, \n           extent=(-5000,5000, 0, 1000),  # scan parameter space\n           cmap='OrRd', origin='lower', aspect='auto')\n# center on global maximum\nplt.ylim([acq_data['delay']*1e6 - 5, acq_data['delay']*1e6 + 5])\nplt.xlim([acq_data['delta_freq'] - 2000, acq_data['delta_freq'] + 2000])\n\nplt.xlabel('Doppler Frequency Shift $\\Delta f$ [Hz]')\nplt.ylabel('Code Delay $\\\\tau$ [$\\\\mu$s]')\nplt.colorbar(label='Signal Power [%]')\nplt.show()\n\n\n\n\n\nFigure 2: Received signal power of one satellite under different demodulation parameters. The full acquisition search region is zoomed in on the peak power.\n\n\n\n\n\n\nSearch Satellites\nWe can search for all satellites in the first few milliseconds of our signal using the acquisition procedure, see Figure 3. Since we expect to see only a handful of satellites, we have to conclude that a the noise floor of around 0.5% power is present in all PRNs: We get spurious signals not originating from senders but noise on all PRNs.\nFive satellites can be identified that send well above the noise floor. Since at least 4 satellites are required for a position fix, we can proceed.\n\n\nCode\nprn_ids = range(1, 38)  # PRN IDs to search for\n\nsignal_strength = np.zeros(len(prn_ids))\nfor i, prn_id in enumerate(prn_ids):\n    signal_slice = baseband.get_interval(to_time=0.05)  # take first 50 ms\n\n    acq = gpswt.Acquisition(prn_id, sampling_dt=baseband.sampling_dt)\n    acq_data = acq.search(signal_slice,\n                          delta_freq_step=500, \n                          delta_freq_range=(-5000,5000)) # increase to 100k for HackRF w/o external clock\n    \n    signal_strength[i] = np.median(np.abs(acq_data['correlator']**2))  # average power\n\nbest_prns = np.argsort(-signal_strength)[:5] + 1\nprint(f'Top-5 PRNs: {best_prns}')\n\nplt.subplots(figsize=(10,2))\nplt.bar(prn_ids, signal_strength * 100, tick_label=prn_ids)\nplt.xlabel('Satellite [PRN #]')\nplt.ylabel('Signal Power [%]')\nplt.show()\n\n\nTop-5 PRNs: [21 16 27  1 32]\n\n\n\n\n\nFigure 3: Received signal power on all 37 C/A codes identified by their PRN number during first 50 ms of the recording.\n\n\n\n\nIf you want to know more about C/A codes, how we detect it in the recording, what the four demodulation parameters exactly mean and how we have to search for them, then wait for walkthrough step 3 to be posted… In the meantime, have a look into the source code of the acquisition and C/A code module."
  },
  {
    "objectID": "posts/gps/step1_overview.html#signal-tracking-and-demodulation",
    "href": "posts/gps/step1_overview.html#signal-tracking-and-demodulation",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "4 Signal Tracking and Demodulation",
    "text": "4 Signal Tracking and Demodulation\nIn order to maintain reception over the time of the recording, we constantly need to readjust to modulation parameters for each satellite. As shown in Figure 4, the satellite’s signal is lost in a fraction of a second if not done so.\n\n\nCode\n# get initial doppler shift and code delay parameters using acquisition procedure\nacq = gpswt.Acquisition(prn_id=16, sampling_dt=baseband.sampling_dt)\nacq_data = acq.search(baseband.get_interval(to_time=0.005))  # first periods only\ndelta_freq_start = np.median(acq_data['delta_freq'])\ndelay_start = np.median(acq_data['delay'])\n\n# tracking with disabled delay-locked loop (DLL)\ntracker = gpswt.Tracking(prn_id=16, sampling_dt=baseband.sampling_dt, \n                         dll_guided=False, dll_ki=0.0,  # disable DLL               \n                         delta_freq_start=delta_freq_start,\n                         delay_start=delay_start)\ntracking_data = tracker.track(baseband.get_interval(to_time=1.0))\n\namplitudes = tracking_data['correlator']\nt = tracking_data['time_code_start']\n\nfig, ax = plt.subplots(figsize=(10, 2.*1))\nax.plot(t, abs(amplitudes)**2 * 100, 'b')\nax.set_xlabel('Receiver Time $t$ [s]') \nax.set_ylabel('Signal Power [%]')\nplt.show()\n\n\n\n\n\nFigure 4: Signal power with a fixed code delay parameter for CDMA demodulation. We lose the signal within a fraction of a second.\n\n\n\n\nConstant readjustment could be performed with the acquisition procedure shown above, by blindly searching the optimal parameters for every millisecond of the signal individually. But there are some major drawbacks using this approach.\nExploiting the fact that the parameters change continuously, we can keep them optimized using control loops: One loop locking on the frequency, one on the code delay, and one on the phase. This procedure is called tracking of the signal and has several advantages compared to the acquisition algorithm: It is much faster since it does not start search blindly from scratch, yields more accurate parameter values, and is more robust to noise.\nThe result of tracking is a\n\nhigh-precision code delay value (for our analysis here we achieve less than 10 nanoseconds) for accurate time-of-flight estimation, and\nthe CDMA-demodulated signal, which allows to decode the telemetry messages sent by each satellite.\n\nTracking of PRN 16 is shown in Figure 5. After a short time period at the beginning where the control loops lock-in on the optimal values, the parameters develop steadily and signal power is maintained.\n\n\nCode\n# get initial doppler shift and code delay parameters using acquisition procedure\nacq = gpswt.Acquisition(prn_id=16, sampling_dt=baseband.sampling_dt)\nacq_data = acq.search(baseband.get_interval(to_time=0.005))  # first periods only\ndelta_freq_start = np.median(acq_data['delta_freq'])\ndelay_start = np.median(acq_data['delay'])\n\ntracker = gpswt.Tracking(prn_id=16, sampling_dt=baseband.sampling_dt,\n                         delta_freq_start=delta_freq_start,\n                         delay_start=delay_start)\ntracking_data = tracker.track(baseband.get_interval(to_time=1.0))\n\namplitudes = tracking_data['correlator']\nt = tracking_data['time_code_start']\n\nfig, ax = plt.subplots(4, 1, sharex=True, figsize=(10, 2.*4))\nax[-1].set_xlabel('Receiver Time $t$ [s]') \n\nax[0].plot(t, abs(amplitudes)**2 * 100, 'b')\nax[0].set_ylabel('Signal Power [%]')\n\nax[1].set_ylabel('Code Delay $\\\\tau$ [$\\mu$s]')\nax[1].plot(t, tracking_data['delay_used'] * 1e6, 'b', label='Used')\nax[1].plot(t, (tracking_data['delay_used'] + tracking_data['discriminator_tau']) * 1e6,\n           'g', label='Measured', alpha=0.5)\nax[1].plot(t, tracking_data['delay'] * 1e6, 'r', label='Estimated')\nax[1].legend()    \n\nax[2].plot(t, tracking_data['delta_freq'], 'm')\nax[2].set_ylabel('Doppler Shift $\\Delta f$ [Hz]')\n    \nax[3].plot(t, tracking_data['phi'], 'g')\nax[3].set_ylabel('Phase $\\Phi$ [rad]')\nplt.show()\n\n\n\n\n\nFigure 5: Tracking of a PRN 16. Code delay, Doppler shift and phase are constantly adjusted to maintain signal reception.\n\n\n\n\nOver the shown time period, the code delay needs to be increased constantly. Equally as for the negative Doppler shift frequency, this is a consequence of the fact that this satellite is heading away from us and its distance is thereby increasing, i.e. its signal arrives more and more delayed over time. Over the shown time period of 1s, we observe an increase of approx. 1.5\\(\\mu\\)s in delay. Multiplied by the speed of light, this corresponds to a speed of roughly 450 m/s. (Notice, that this value does not reflect the satellite’s speed, but only to its component along the line of sight from us.)\n\nBPSK Demodulation\nEach GPS L1 satellite sends navigation messages (LNAV) which contains the telemetry data. These messages are modulated onto the CDMA signal using binary phase-shift keying (BPSK). We see in Figure 6, after the lock-in phase of the tracking, that a clean digital signal can be observed. Obviously, the BPSK demodulation yielding the binary information is straightforward.\n\n\nCode\nfig, ax = plt.subplots(figsize=(10, 2.))\nax.plot(t, np.real(amplitudes) / np.abs(amplitudes), 'c')\nax.set_ylabel('Norm. In-Phase $I \\, / \\, |A| $')\nax.set_xlabel('Receiver Time $t$ [s]')\n\nplt.show()\n\n\n\n\n\nFigure 6: CDMA-Demodulated telemetry signal of a satellite.\n\n\n\n\nA different method allowing to visualize digital modulation of a signal over longer time periods are constellation diagrams. In Figure 7, we observe that later CDMA demodulated samples (blue, green, yellow), where signal tracking locked after startup (purple), fall into two well distinguishable spots. These are the two states encoding a bit in the BPSK scheme. That means that the signal tracking and CDMA demodulation is reliable over the first 10s, and BPSK demodulation will work flawlessly.\n\n\nCode\ntracker = gpswt.Tracking(prn_id=16, sampling_dt=baseband.sampling_dt, \n                         delta_freq_start=acq_data[0]['delta_freq'],\n                         delay_start=acq_data[0]['delay'])\ntracking_data = tracker.track(baseband.get_interval(to_time=10))  # 10 s interval\namplitudes = tracking_data['correlator']\n\nfig, ax = plt.subplots(figsize=(10,4))\nax.scatter(np.real(amplitudes), np.imag(amplitudes), \n           marker='.', alpha=0.3, c=range(len(amplitudes)))\nax.set_aspect('equal', 'box')\nax.set_xlabel('In-phase $I$')\nax.set_ylabel('Quadrature $Q$')\nax.grid(which='major')\nplt.show()\n\n\n\n\n\nFigure 7: Constellation diagram of CDMA-demodulated signal during the first 10 seconds. Color indicates reception time from start (purple) to end (yellow). A point represent the IQ sample of one C/A code.\n\n\n\n\n\n\nTrack and Demodulate All\nWe can now get the navigation messages being sent by performing all steps shown above for each satellite:\n\nAcquisition, to find initial demodulation parameters.\nTracking, to follow the parameters over long recording time and get CDMA demodulation.\nBPSK demodulation, to get the encoded binary stream of the navigation messages.\n\n\n\nCode\nprint(f'Analyzing signal of length {baseband.duration():.1f} s:')\npseudo_symbols = {}\ntracking_data = {}\nfor prn_id in best_prns:\n    print(f'PRN {prn_id}:', end='')\n\n    print('  Acquisition... ', end='')\n    acq = gpswt.Acquisition(prn_id, sampling_dt=baseband.sampling_dt)\n    acq_data = acq.search(baseband.get_interval(to_time=0.05))  # check first 50ms = 50 code periods\n\n    delta_freq_start = np.median(acq_data['delta_freq'])\n    delay_start = np.median(acq_data['delay'])\n\n    print(f'  Tracking... ', end='')\n    tracker = gpswt.Tracking(prn_id, sampling_dt=baseband.sampling_dt,\n                             delta_freq_start=delta_freq_start,\n                             delay_start=delay_start)\n    tracking_data[prn_id] = tracker.track(baseband, progress=False)  # track full signal length\n\n    print(f'  BPSK Demodulation... done.')\n    pseudo_symbols[prn_id] = \\\n        np.real(tracking_data[prn_id]['correlator']) &gt; 0  # distinguish between 0 and 1\n\n\nAnalyzing signal of length 84.3 s:\nPRN 21:  Acquisition...   Tracking...   BPSK Demodulation... done.\nPRN 16:  Acquisition...   Tracking...   BPSK Demodulation... done.\nPRN 27:  Acquisition...   Tracking...   BPSK Demodulation... done.\nPRN 1:  Acquisition...   Tracking...   BPSK Demodulation... done.\nPRN 32:  Acquisition...   Tracking...   BPSK Demodulation... done.\n\n\nThis is rather lengthy calculation, taking almost 10 minutes on my laptop for the given length of the recording. Certainly, the algorithm’s are not at all optimized for speed, but are roughly 20 times faster than the acquisition procedure is.\nIf you want to know more about control loops, signal processing, demodulation, wait for the walkthrough step 4 to be published. In the meantime, have a look into the source code of the tracking module.\n\n\nCode\n# to avoid running tracking again, save the output for later experimentation...\n\nimport pickle\n# if pseudo_symbols and tracking_data:  # save the data if present\n#     with open('psymbols.pickle', 'wb') as f:\n#         pickle.dump(pseudo_symbols, f)\n#     with open('trackdata.pickle', 'wb') as f:\n#         pickle.dump(tracking_data, f)\n\n# with open('psymbols.pickle', 'rb') as f:  # load it from file if available\n#     pseudo_symbols = pickle.load(f)\n# with open('trackdata.pickle', 'rb') as f:\n#     tracking_data = pickle.load(f)\n# best_prns = list(pseudo_symbols.keys())"
  },
  {
    "objectID": "posts/gps/step1_overview.html#telemetry-decoding",
    "href": "posts/gps/step1_overview.html#telemetry-decoding",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "5 Telemetry Decoding",
    "text": "5 Telemetry Decoding\nThe telemetry data sent in navigation messages by all satellites contain information about their orbital parameters as well as clock error information of the on-board atomic clocks. Both are required for calculating a satellite’s position very accurately at every moment in time.\nThe BPSK demodulation done above yields a binary stream. Its constituents are called pseudo-symbols. The actual information carrying bits, used for encoding the telemetry message, consist of 20 identically repeated pseudo-symbols. Messages sent by the satellite are encoded in a data structure called which consists of give subframes. To get the frame data, we have to perform the following steps:\n\nBit synchronization: Find out where in the stream of pseudo-symbols a bit starts.\nBit decoding: Decode the pseudo-symbols and generate the stream of bits.\nFrame synchronization: Find the start of a frame in the stream of bits.\nFrame dissection: Read the frame data structure, check its validity using checksums, and represent it in a usable form.\n\nLet’s do that for all satellites:\n\n\nCode\ntelemetry = {}\nfor prn_id in best_prns:\n    print(f'PRN {prn_id}')\n    \n    bits, bit_start_symbol = gpswt.telemetry.bit_synchronize(pseudo_symbols[prn_id])\n    bits, subframe_start_bit = gpswt.telemetry.subframe_synchronize(bits)\n    telemetry_data = gpswt.telemetry.subframe_dissect(bits, subframe_start_bit, bit_start_symbol)\n    \n    telemetry[prn_id] = telemetry_data\n    print()\n\n\nPRN 21\nBits: synced, avg. pseudo-symbol errors per bit: 0.002\nSubframes: synced, found 14, valid 13\nDissection: 13 subframes decoded.\n\nPRN 16\nBits: synced, avg. pseudo-symbol errors per bit: 0.003\nSubframes: synced, found 14, valid 13\nDissection: 13 subframes decoded.\n\nPRN 27\nBits: synced, avg. pseudo-symbol errors per bit: 0.001\nSubframes: synced, found 14, valid 13\nDissection: 13 subframes decoded.\n\nPRN 1\nBits: synced, avg. pseudo-symbol errors per bit: 0.002\nSubframes: synced, found 14, valid 13\nDissection: 13 subframes decoded.\n\nPRN 32\nBits: synced, avg. pseudo-symbol errors per bit: 0.004\nSubframes: synced, found 14, valid 13\nDissection: 13 subframes decoded.\n\n\n\nWe see from the output that the telemetry data of all five satellites was successfully decoded. While a few pseudo-symbols are reported to be faulty, the signal quality was good enough that almost all subframes were valid, i.e. contain no bit errors.\nLet’s have a look at the telemetry data of one of the satellites. The first five received subframes read\n\n\nCode\nfor i in range(5):  # show a full frame = 5 subframes\n    print(telemetry[16][i])\n\n\n{'start_symbol': 3964, 'subframe_id': 1, 'integrity': 0, 'time_of_week': 52116, 'clock': {'week_number': 213, 'sv_health': 0, 'T_GD': -1.0244548320770264e-08, 't_oc': 57600, 'a_f2': 0.0, 'a_f1': 3.183231456205249e-12, 'a_f0': -0.0005030031315982342}}\n{'start_symbol': 9964, 'subframe_id': 2, 'integrity': 0, 'time_of_week': 52122, 'ephemeris': {'C_rs': 131.75, 'dn': 4.2019607428169266e-09, 'M_0': -3.0335492879613675, 'C_uc': 1.642853021621704e-06, 'e': 0.01333794859237969, 'C_us': 9.84780490398407e-06, 'sqrtA': 5153.60133934021, 't_oe': 57600}}\n{'start_symbol': 15964, 'subframe_id': 3, 'integrity': 0, 'time_of_week': 52128, 'ephemeris': {'C_ic': -9.313225746154785e-09, 'Omega_0': 0.6220877159703716, 'C_is': -2.3096799850463867e-07, 'i_0': 0.965627893317696, 'C_rc': 192.03125, 'omega': 0.7866631281797375, 'Omega_dot': -7.618888785870861e-09, 'I_dot': 6.321691895270685e-11}}\n{'start_symbol': 21964, 'subframe_id': 4, 'integrity': 0, 'time_of_week': 52134}\n{'start_symbol': 27964, 'subframe_id': 5, 'integrity': 0, 'time_of_week': 52140}\n\n\nThe subframes data structure contains:\n\ntime_of_week: exact time of sending of this subframe by the satellite in seconds, as measured by the satellite’s atomic clock,\nclock: satellite clock correction data, since the atomic clocks need still some correction to be accurate enough for our purposes,\nephemeris: parameters required to calculate the satellite orbit positions at any time,\nmeta data added by the telemetry decoder (e.g. the subframe’s start pseudo-symbol index, start_symbol, in the sequence of recorded symbols).\n\nWe can observe that a subframe is transmitted every 6 seconds (steps in time_of_week), and that one subframe is encoded using 6000 pseudo-symbols (steps in start_symbol).\nIf you want to know more about synchronization, decoding, dissetion and the GPS L1 navigation message data structures, wait for the walkthrough step 5 to be published. In the meantime, have a look into the source code of the telemetry module."
  },
  {
    "objectID": "posts/gps/step1_overview.html#pseudorange-measurement",
    "href": "posts/gps/step1_overview.html#pseudorange-measurement",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "6 Pseudorange Measurement",
    "text": "6 Pseudorange Measurement\nIn order to calculate our position, we need to perform measurements of so called observables. The one we will consider here is called pseudorange. It represents a measurable quantity which is related to the distance between the receiver and a satellite. The pseudorange to satellite i is defined by\n\\[ R_i = c \\, (t_{i} - T_{i}) \\]\nwith the speed of light \\(c\\), the receiving time \\(t_i\\) of a signal as measured by the receiver, and the send time \\(T_i\\) of this signal as measured by satellite i’s atomic clock in GPS time. Therefore, measuring \\(t_i\\) and decoding \\(T_i\\) from the telemetry allows us to infer \\(R_i\\).\nThe reason why this is not the actual range or distance: While \\(T_i\\) is very accurate thanks to the atomic clocks and their correction information available through telemetry, the cheap receiver clock built into our SDR, on which we base our measurements of \\(t_r\\), is not accurate at all. Furthermore, the speed of light might not correspond to the radio wave’s effective speed of propagation (atmosphere’s influence). These discrepancies make the pseudorange deviate from the actual, physical distance and have to be taken into account later.\nLet’s have a look at pseudoranges of PRN 16 during the first few seconds:\n\n\nCode\npseudo_range = gpswt.observables.pseudo_ranges(telemetry[16], tracking_data[16], \n                                               observation_interval=1.0)\nfor k in range(4):\n    print(f\"t_i = {pseudo_range['receive_time'][k]:.6f} s, \"\n          f\"T_i = {pseudo_range['send_time_gps'][k]:.6f} s, \"\n          f\"R_i - r = {pseudo_range['pseudo_range'][k] - pseudo_range['pseudo_range'][0]:.2f} m\")\n\n\nt_i = 0.000000 s, T_i = 52106.036490 s, R_i - r = 0.00 m\nt_i = 1.000000 s, T_i = 52107.036488 s, R_i - r = 543.89 m\nt_i = 2.000000 s, T_i = 52108.036486 s, R_i - r = 1085.70 m\nt_i = 3.000000 s, T_i = 52109.036485 s, R_i - r = 1626.99 m\n\n\nA comparison between the receiver time \\(t_i\\) and the send time \\(T_i\\) reveals that they are roughly in sync, but off by almost a day. In the last shown digits of \\(T_i\\), we can observe that the signal received at the integer values \\(t_i\\) are sent earlier and earlier, explained by an increasing in distance and pseudorange. Its change is reported as \\(R_i - r\\), where \\(r\\) is a constant. We can read off a receding speed of approx. 540 m/s of the satellite (again only in line of sight).\nLet’s measure the pseudoranges for all satellites as we need them in our next steps.\n\n\nCode\nposition_fix_time_interval = 0.5\nprint(f'Measurement Time Interval: {position_fix_time_interval} s\\n')\n\npseudo_ranges = {}\nfor prn in best_prns:\n    print(f'Measuring pseudoranges for PRN {prn}...')\n    pseudo_ranges[prn] = gpswt.observables.pseudo_ranges(telemetry[prn], tracking_data[prn], \n                                                         position_fix_time_interval)\n\n\nMeasurement Time Interval: 0.5 s\n\nMeasuring pseudoranges for PRN 21...\nMeasuring pseudoranges for PRN 16...\nMeasuring pseudoranges for PRN 27...\nMeasuring pseudoranges for PRN 1...\nMeasuring pseudoranges for PRN 32...\n\n\nIf you want to know more about the measurement of the nanosecond accurate time of reception, pseudoranges, clock corrections, then wait for the walkthrough step 6 to be published. In the meantime, have a look into the source code of the observables module."
  },
  {
    "objectID": "posts/gps/step1_overview.html#satellite-orbital-position-calculation",
    "href": "posts/gps/step1_overview.html#satellite-orbital-position-calculation",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "7 Satellite Orbital Position Calculation",
    "text": "7 Satellite Orbital Position Calculation\nIn order to infer our position from the measured pseudoranges, we additionally need to know the position of each satellite at the time of sending a signal. As we want to know our position at meter accuracy, we better know the satellites position at the same accuracy at every instant of time.\nKepler’s equation allows to calculate orbits, i.e. position at any time, of objects (satellites) under the gravitational influence of a central mass (earth). Things would unfortunately not work out at the required accuracy, because some assumptions underlying this equation are violated:\n\nThe central mass is homogenous and spherical: As we know when climbing mountains, the earth shows some deviations to this.\nNo other other forces are present: The moon and sun influence the orbit with their gravitational forces, and there is a non-negligible “air” resistance due to particles in space.\n\nThese effects need to be considered and put a correction on top of Kepler’s solution. For this, all required information is sent in the ephemeris parameters in the telemetry messages.\nTherefore, let’s calculate the position of the satellite sending PRN 16 at GPS time 0, at the beginning of the current week, and 12 hours later:\n\n\nCode\n# extract complete set of ephemeris data from subframes\nephemeris_subframes = [subframe['ephemeris'] for subframe in telemetry[16] \n                       if 'ephemeris' in subframe.keys()]\nephemeris = {}\nfor subframe in ephemeris_subframes:\n    ephemeris.update(subframe)\n\nt = np.array([0, 11.97*60*60])  # GPS time in seconds\npos = gpswt.ephemeris.sat_position(t, ephemeris)\n\nfor ti, posi in zip(t, pos):\n    print(f't = {ti/3600:&gt;5.2f}h, (x,y,z) = ({posi[0]/1000:&gt;10.3f}, '\n          f'{posi[1]/1000:&gt;10.3f}, {posi[2]/1000:&gt;10.3f}) km')\n\n\nt =  0.00h, (x,y,z) = (-15948.384,   5789.441,  20242.277) km\nt = 11.97h, (x,y,z) = ( 15983.496,  -5760.857,  20223.744) km\n\n\nThe shown \\((x,y,z)\\) coordinate is this satellite’s position in the GPS coordinate system WGS84. It is as earth-centered earth-fixed (ECEF) system, i.e. \\((0,0,0)\\) is at the earth’s center, the \\(z\\) axis is along to rotation axis, and the whole system is rotating together with the earth, such that a fixed position on the surface does not change coordinates with time.\nWe can directly read off the corotating behavior: GPS satellite’s have a orbital period of approx. 12 hours. Therefore, we would expect to two positions reported above to be identical. This is almost the case, were it not for the minus signs change in \\(x\\) and \\(y\\) coordinates. In 12 hours, the earth spun half a rotation around the \\(z\\) axis, changing the coordinates of the same physical position (in a inertial frame) exactly in the observed manner, i.e. turning \\((x,y,z) \\rightarrow (-x,-y,z)\\).\nFrom the reported satellite position we derive:\n\n\nCode\nprint(f'Sat. distance from earth center: {np.sqrt(np.sum(pos[0]**2))/1e3 :.3f} km')\nprint(f'Sat. altitude from surface:      {np.sqrt(np.sum(pos[0]**2))/1e3 - gpswt.ephemeris.EARTH_RADIUS/1e3 :.3f} km')\n\n\nSat. distance from earth center: 26412.466 km\nSat. altitude from surface:      20034.329 km\n\n\nFinally, we can calculate the position of every satellite for every point in time in our wave recording.\n\n\nCode\nsatellite_positions = {}\nfor prn in best_prns:\n    print(f'Calculating satellite positions of PRN {prn}...')\n    ephemeris_subframes = [subframe['ephemeris'] for subframe in telemetry[prn] \n                           if 'ephemeris' in subframe.keys()]\n    ephemeris = {}\n    for subframe in reversed(ephemeris_subframes):  # use newest ephemeris data\n        ephemeris.update(subframe)\n        \n    send_time_gps = pseudo_ranges[prn]['send_time_gps']\n    satellite_positions[prn] = gpswt.ephemeris.sat_position(send_time_gps, ephemeris)\n\n\nCalculating satellite positions of PRN 21...\nCalculating satellite positions of PRN 16...\nCalculating satellite positions of PRN 27...\nCalculating satellite positions of PRN 1...\nCalculating satellite positions of PRN 32...\n\n\nIf you want to know more about solving the Kepler’s equation, its required corrections, coordinate systems and illustration of orbits, then wait for the walkthrough step 7 to be published. In the meantime, have a look into the source code of the ephemeris module."
  },
  {
    "objectID": "posts/gps/step1_overview.html#position-fixing",
    "href": "posts/gps/step1_overview.html#position-fixing",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "8 Position Fixing",
    "text": "8 Position Fixing\nIn this last step of our journey, we finally will get our location, a position fix. From our measured pseudoranges and the satellite’s positions, we should be able to infer it. This process is called PVT solving, since we get position (P) and velocity (V) of the receiver and an accurate time (T).\nThe PVT solver algorithm is sketched in Figure 8. Starting from an initial estimate of P, V and T, we need a model which generates the observables one would measure in this situation (model observables). Then a comparison of this model output with the actually measured quantities (measured observables) determines the mismatch and estimates how much the initial PVT estimate was off to get a smaller mismatch. This process is iteratively repeated until the model and measurement match good enough. We arrive at a PVT fix.\n\n\n\n\n\nflowchart LR\n  E[/PVT Estimate/] --&gt; A[Measurement\\nModel] \n  A --&gt; D[Model\\nObservables] --&gt; B[Observables Mismatch]\n  X[/Measured\\nObservables/] --&gt; B\n  B --&gt; F[PVT Correction]\n  F --&gt; E\n\n\nFigure 8: PVT solving process from measured observables as input to the PVT estimate as output.\n\n\n\n\nIn our case, the observables are the pseudoranges, and the model contains the satellite positions. It calculates euclidean distances between them and the current position estimate. The earth center \\((0,0,0)\\) as initial position is good enough as a starting point and the process converges to the true position and time. Here, we neglect velocity V and assume a stationary receiver. The iterative procedure reduces to a simple least-squares optimization problem which is solved by the gradient descent method.\n\nPosition Analysis\nLet’s do that on our data and transform the WGS84 coordinates to better known longitude and latitude:\n\n\nCode\nposition_solution = gpswt.pvt_solver.position_fix(pseudo_ranges, satellite_positions)\n\npositions_ellipsoid = np.array([gpswt.coordinates.ecef_to_ellipsoid(*pos[0:3])\n                                for pos in position_solution])\nreceive_pos_ellipsoid = np.mean(positions_ellipsoid, axis=0)\n\nprint(f'Average Position: {receive_pos_ellipsoid[0]:0.1f}XX°N,'\n      f' {receive_pos_ellipsoid[1]:.1f}XX°E,' \n      f' {receive_pos_ellipsoid[2]:.2f} m Altitude')\n\n\nAverage Position: 46.9XX°N, 7.4XX°E, 656.40 m Altitude\n\n\n(Since my home is such a calm place, i censored some of the digits in order to keep it like that.) The big question is, whether this is correct. Entering it in Google maps marks a spot which is only 2 meters away from my balcony where the receiver sits! The altitude matches within 10 meters with what the ‘GPSTest’ app on my smartphone shows. We have found the receiver’s location in a volume of space spanning tens of thousands of kilometers in diameter! Isn’t it cool? 😀\nThe above position is a long time average over the recording. In Figure 9, we can see how the position fix varies over time. Since the receiver was stationary, variations have to be attributed to errors in measurement and PVT model. The discrepancy between the measured and modelled pseudoranges are shown in Figure 10 for every satellite. For some of them, 5 to 10 meters distance errors (corresponding to 15-30 nanoseconds) couldn’t be reduced by a more optimal PVT solution. These residuals cannot be explained by the model.\nThere is a reasons for the variation and residuals: Our model does not incorporate atmospheric effects. They influences radio propagation speed and thereby our estimation of the pseudorange. Some of them could be addressed: Ionosphere and troposphere data would be available in telemetry. (Feel free to send me a pull request to add this feature 😉) Other more localized variations of the atmosphere cannot be modelled and will remain as residuals. Taking into account a better model and other satellite system would allow a more stable and accurate position fix.\n\n\nCode\ndelta = position_solution - np.mean(position_solution, axis=0)\ndelta = np.vstack([gpswt.coordinates.ecef_to_local(pt, \n                                             receive_pos_ellipsoid[0], \n                                             receive_pos_ellipsoid[1], \n                                            ) for pt in delta[:, 0:3]])\nreceiver_time = pseudo_ranges[best_prns[0]]['receive_time']\n\nplt.figure(figsize=(15,3))\nplt.plot(receiver_time, delta[:, 0], label='East')\nplt.plot(receiver_time, delta[:, 1], label='North')\nplt.plot(receiver_time, delta[:, 2], label='Up')\nplt.ylabel('Position Fix Variation [m]')\nplt.xlabel('Receiver Time [s]')\nplt.ylim([-20,30])\nplt.legend()\nplt.show()\n\n\n\n\n\nFigure 9: Position fix variation from mean value, in local ENU coordinates.\n\n\n\n\n\n\nCode\npseudo_range_errors = np.vstack([gpswt.pvt_solver._position_fix_error_function(x, ti, pseudo_ranges, satellite_positions) \n                                 for ti, x in enumerate(position_solution)])\nplt.figure(figsize=(15,3))\nfor prn_index, prn in enumerate(best_prns):\n    plt.plot(receiver_time, pseudo_range_errors[:, prn_index], label=f'PRN {prn}')\nplt.ylabel('Pseudorange Residual [m]')\nplt.xlabel('Receiver Time [s]')\nplt.legend()\nplt.show()\n\n\n\n\n\nFigure 10: Pseudorange residuals, i.e. not explained mismatch from model pseudorange at optimal position/time solution, for all satellites.\n\n\n\n\n\n\nReceiver Clock Analysis\nIn addition to the position, we also get a very accurate GPS time in the PVT solving process. With this we can analyze how accurate our clock is. As mentioned in Section 2, a Siglent function generator was used as a high-precision reference clock. The spec sheet reports a precision of better than \\(10^{-6}\\), i.e. less than a microsecond off per second. Let’s have a look wether that’s true:\n\n\nCode\nfrom scipy import stats\n\n# bias = difference between receiver time and GPS time\nclock_bias = receiver_time - position_solution[:, 3]\nfit_bias = stats.linregress(receiver_time, clock_bias)\n\n# a perfect receiver clock has slope = 1 s/s, but we get\nprint(f'Average clock drift: {(fit_bias.slope - 1) * 1e6:0.2f} microseconds/second')\n\n\nAverage clock drift: 0.50 microseconds/second\n\n\nIndeed we find that the promise is hold, it is only slightly too fast. What about the long term stability? In Figure 11, we see slight variations of less than \\(\\pm 0.5\\mu s\\) within 80 seconds recording period. The clock is rather stable.\n\n\nCode\nplt.figure(figsize=(15,2.5))\nplt.plot(receiver_time, (clock_bias - receiver_time*fit_bias.slope - fit_bias.intercept) * 1e6)\nplt.ylabel('Non-Linear Clock Bias [$\\mu s$]')\nplt.xlabel('Receiver Time [s]')\nplt.show()\n\n\n\n\n\nFigure 11: Receiver clock stability. The clock bias is shown with its linear component (clock drift) removed.\n\n\n\n\n\n\nPosition and Satellite Visualization\nTo conclude, we visualize our location and satellites in Figure 12. Obviously we only see satellites which are above the horizon, i.e. a direct line of sight is not blocked by the earth.\nAnd again, if you want to know more about PVT solving, then wait for the walkthrough step 8 to be published. In the meantime, have a look into the source code of the PVT solver module.\nI hope you enjoyed the journey! Feel free to contact me and please leave your comments below. If you appreciated this article and you can afford it, how about to buy me a coffee?\n\n\n\n\n\nCode\nfig = plt.figure(figsize=(15,15))\nax = fig.add_subplot(projection='3d')\nax.set_proj_type('ortho')\n    \n# plot earth in spherical approximation\nR = 6378137 / 1000 # [km] earth radius\nu, v = np.meshgrid(np.linspace(0, 2*np.pi, 25),  # wireframe for every 15°\n                   np.linspace(0, np.pi, 13)) \nx = R * np.cos(u) * np.sin(v)\ny = R * np.sin(u) * np.sin(v)\nz = R * np.cos(v)\nax.plot_wireframe(x, y, z, alpha=0.2, color='blue')\n\n# add equator and null meridian\nu = np.linspace(0,2*np.pi, 25)\nax.plot(R * np.cos(u), R*np.sin(u), 0*u, color='black')\nax.plot(R * np.cos(u), 0*u, R*np.sin(u), color='black')\n\n# draw equatorial plane\nx, y = np.meshgrid(np.linspace(-5*R, 5*R, 20), \n                   np.linspace(-5*R, 5*R, 20))\nz = 0 * x\nax.plot_surface(x, y, z, alpha=0.2, color='gray')\n\n# plot our position in red\nax.stem(*(position_solution[:, 0:3]/1000).transpose(), \n        markerfmt='or', bottom=0, orientation='z')\n\n# plot satellites position\nfor prn in best_prns:    \n    ax.stem(*(satellite_positions[prn][-2:-1]/1000).transpose(), \n            markerfmt='og', bottom=0, orientation='z')\n    ax.text(*(satellite_positions[prn][-1]/1000 + [0,0,1000]), str(prn), None)\n\nax.set_box_aspect([ub - lb for lb, ub in (getattr(ax, f'get_{a}lim')() for a in 'xyz')])  # set equal aspect ratio\nax.set_xlabel(('x [km]'))\nax.set_ylabel(('y [km]'))\nax.set_zlabel(('z [km]'))\nplt.show()\n\nplt.figure(fig)\nax.view_init(90,90)\nfig.set_size_inches(8,8)\nplt.show()\n\nplt.figure(fig)\nax.view_init(0,90)\nfig.set_size_inches(8,8)\n\n\n\n\n\n\n\n\n(a) Earth with indicated equator and prime meridian, our position (red), and satellites in WGS84 coordinate system. Stems are drawn from the equatorial plane (gray).\n\n\n\n\n\n\n\n\n\n(b) Top View.\n\n\n\n\n\n\n\n(c) Side View.\n\n\n\n\nFigure 12: Visualization of the geometric situation in a moment during the GPS radio wave recording."
  },
  {
    "objectID": "posts/gps/step1_overview.html#sec-refs",
    "href": "posts/gps/step1_overview.html#sec-refs",
    "title": "GPS Walkthrough 1 — Overview",
    "section": "References",
    "text": "References\n\nnavipedia GPS L1 C/A\nWikipedia GPS L1 C/A\ngnss-sdr GPS L1 C/A\ngps.gov IS-GPS-200 GPS specification (PDF)\nCalculating Position from Raw GPS Data, blog post by Ankur Mohan\n\nSee also more specific technical references in the source code of the gps_walkthrough python module."
  },
  {
    "objectID": "posts/gps/step0_intro.html",
    "href": "posts/gps/step0_intro.html",
    "title": "GPS Walkthrough – A Journey from Radio Wave to Position Fix",
    "section": "",
    "text": "For other articles in this series, have a look at the GPS walkthrough index."
  },
  {
    "objectID": "posts/gps/step0_intro.html#introduction",
    "href": "posts/gps/step0_intro.html#introduction",
    "title": "GPS Walkthrough – A Journey from Radio Wave to Position Fix",
    "section": "Introduction",
    "text": "Introduction\nHave you ever wondered how the Global Positioning System (GPS) actually works in detail? I did as well, and wanted to dive into it one day…\nAt the beginning of 2023, I stumbled across the very nice article by Ankur Mohan about “Calculating Position from Raw GPS Data”. It finally kindled my motivation to start the long forseen project. While Ankur’s article covers many interesting aspects of GPS, some are missing due to the fact that he relies on a GPS receiver which takes care of radio wave processing and time-of-flight calculation.\nI wanted to fill in these gaps since my original motivation was to know GPS from radio wave to position fix. At first, it was at unclear how realistic this goal is. But here it is: After quite a few rather long nights, I finally know my balcony’s GPS coordinates!\nDue to the very diverse topics involved, I found that it might be interesting for others as well. The idea of a walkthrough was born, where we go step-by-step together with theoretical explanations, practical number-crunching and visualizations along the way. To be honest: This journey involves quite a deal of machinery. But in order achieve the goal to really understand it in-depth, we will never rely on black boxes (like high-level software routines) but start from first-principles available to anyone with some highschool math background or good motivation to look things up. Be prepared to learn about\n\nradio waves and their mathematical description,\nradio receivers and their inner workings,\nradio signal modulation and demodulation,\ndigital signal processing, filters, and control loops,\nGPS (!), its radio signal, telemetry data, and coordinate systems,\na little physics, as in Doppler shift, Sagnac effect, relativistic time dilation, and orbit calculation,\nflat earth hypothesis is rather difficult to defend considering the results we get here,\nand the metric units system might be not such a bad idea after all.\n\nIn case you managed to read this far and are still interested, despite of these details we will have to deal with, you are very welcome to continue with me. I promise that at the end we will find the location of my (or your) balcony to better than 2 meters accuracy within a volume of space of more than 50’000 km in diameter!"
  },
  {
    "objectID": "posts/gps/step0_intro.html#walkthrough-steps",
    "href": "posts/gps/step0_intro.html#walkthrough-steps",
    "title": "GPS Walkthrough – A Journey from Radio Wave to Position Fix",
    "section": "Walkthrough Steps",
    "text": "Walkthrough Steps\nThe GPS walkthrough investigates the GPS L1 C/A signal1 by performing the analysis in Python using NumPy. It consists of the following steps, each with its dedicated blog post:\n\n\n\n\n\n\nJupyter Notebooks\n\n\n\nYou want to follow the steps by computing the results yourself or applying it on your own signals? Check out the Jupyter notebooks which will be published simultaneously with the blog posts on gps-walkthrough repository.\n\n\n\nOverview: This post gives an overview by quickly going over all steps and their results, i.e. from radio wave recording to the calculation of the position fix. Detailed analysis and explanations are lacking here. I hope this motivates you to dive deeper in the following.\nRadio Wave Theory and Recording: I explain how to use the HackRF receiver and a GPS antenna for recording of the GPS radio wave. In case this hardware equipment is not available, it is shown how to be generated artificially. The recording is read and analyzed for signal quality.\nFor getting an understanding of the recorded data as required later, a mathematical model of the radio wave is introduced and the basic principles of a radio receiver sketched. We look into numerical examples and their visualizations for intuition of the theory, as well as an introduction to NumPy.\n\n\n\n\n\n\n\nRecord your own GPS signal?\n\n\n\n\n\nYou want to record your own GPS signal and analyze it? This equipment is needed:\n\nSDR receiver (e.g. HackRF or RTL-based) capable to receive at 1575 MHz. Unlike other GPS software receivers, no precise clock reference is required here.\nActive GPS antenna with at least 25dB gain. A cheap 10$ one is sufficient (e.g. MikroTik ACGPSA).\nBias tee voltage supply if the SDR does not support powering the antenna. (Not required for HackRF with antennas accepting 3.3 Volts.)\n\nAfter having this available, be patient for this post to get published for detailed instructions…\n\n\n\n\nGPS Signal Theory and Acquisition: GPS Signals are very low power, even weaker than background noise picked up from environment. Knowledge of the sent signal type is required in order to detect it using correlation techniques. Here we investigate the specific nature of the GPS signal and play with its properties.\nFurthermore, we have to discuss effects which distort the received signal. Having this in mind, we finally are able to detect the GPS signal in our recording and identify the available satellites and their signal strength.\nSignal Tracking: The former acquisition step needed to perform a blind search for every satellite, which showed to be rather instable to noisy signals and expensive in terms of computation time, even for very short time periods. But once that we found a signal by this procedure, we will find out together how to lock onto it and keep reception stable. This allows us to demodulate the data stream being sent efficiently.\nTelemetry Decoding and Orbital Position Calculation: Having a demodulated signal at hand, we get the transmitted bits and bytes after a straightforward synchronization procedure. We dive a little into the specs of GPS. This allows us interpret the telemetry messages with its very precise send time information and orbital parameters.\nUsing the telemetry information, we can calculate the position of every satellite at every instant of time. Despite their high velocity (4 km/s) and altitude (20’000 km), this better happens at an accuracy below a few meters, since we cannot expect a high position fix accuracy if we don’t know the satellite positions equally well.\nPseudo-Range and Position Fix Calculation: The send time information and the actual moment of reception, as measured by our receiver’s clock, allows us to determine the time-of-flight of the signal from every satellite independently. Since we have no atomic but a cheap, inaccurate receiver clock, we will need to compensate for this accordingly. The time-of-flight translates to an apparent distance, called pseudo-range, due to the (nearly) constant speed of light. To get the desired positioning accuracy, we need to achieve a time-of-flight error below a few nanoseconds.\nHaving come this far, we now know for every moment in our recording the positions of every satellite and their distance from us. Using suitable optimization methods, we find our position with a few meters accuracy within the huge space spanning tens of thousands of kilometers!\n\nPlease be patient for these announced posts to be published and motivate me with encouraging comments 🙂 If you want to be noticed about it, subscribe to my newsletter. Already available posts can be found here."
  },
  {
    "objectID": "posts/gps/step0_intro.html#footnotes",
    "href": "posts/gps/step0_intro.html#footnotes",
    "title": "GPS Walkthrough – A Journey from Radio Wave to Position Fix",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nFor GPS L1 C/A details, see https://gssc.esa.int/navipedia/index.php/GPS_Signal_Plan#GPS_L1_Band and https://en.wikipedia.org/wiki/GPS_signals#Legacy_GPS_signals.↩︎"
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html",
    "title": "Polygon Smoothing Riddle",
    "section": "",
    "text": "A random polygon evolves into an ellipse if we iteratively generate a new polygons with its edges being the center of the previous polygon: https://www.jasondavies.com/random-polygon-ellipse/\nThis phenomenon was recently brought forward in a notable but private discussion board by Dr. R. M. Of course, the following questions immediatley arise:\nWe try to address these in the following."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#definition",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#definition",
    "title": "Polygon Smoothing Riddle",
    "section": "Definition",
    "text": "Definition\nWe represent polygon points by numbers in the complex plane. This will turn out to lead to an elegant description of the phenomenon.\nThe averaging / smoothing of the polygon by calculating the point centers is implemented with\n\nimport numpy as np\n\ndef do_smoothing(points, steps):\n    \"\"\"Build average of neighboring points, apply it multiple times.\"\"\"\n    \n    for i in range(steps):\n        points = (points + np.roll(points, 1))/2 \n        \n    return points\n\nWe need to visualize a list of points as polygons in the following. We define this helper function by\n\nimport matplotlib.pyplot as plt\n\ndef show_points(points, ax=None, labels=True, dots=True, linewidth=0.5):\n    \"\"\"Plot all points in complex plane. If given, use the axis given, otherwise build new figure.\"\"\"\n    \n    X = [x.real for x in points]\n    Y = [x.imag for x in points]\n    X.append(X[0]) # start point is end point\n    Y.append(Y[0])\n    \n    if ax == None:\n        fig = plt.figure(figsize=[4,4])\n        ax = fig.add_subplot(111)\n        \n    ax.set_aspect('equal', 'datalim')\n\n    if dots: ax.scatter(X,Y, color='red')\n    ax.plot(X,Y, color='black', linewidth=linewidth)\n    \n    if labels:\n        for i in range(len(points)):\n            ax.annotate(i, (X[i], Y[i]), textcoords=\"offset points\", xytext=(0,10))"
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#polygon-evolution-example",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#polygon-evolution-example",
    "title": "Polygon Smoothing Riddle",
    "section": "Polygon Evolution Example",
    "text": "Polygon Evolution Example\nLet us reproduce the phenomenon with an example. A random polygon is chosen by\n\nN = 13\ninit_points = np.random.standard_normal(N) + np.random.standard_normal(N)*1j\nshow_points(init_points)\n\n\n\n\nLet the smoothing process evolve:\n\npoints = init_points\n\n# iterate smoothing:\nsteps = 3 # steps between plots\nplt.figure(figsize=[10,10]) \nfor i in range(16):\n    ax = plt.subplot(4,4,i+1)\n    show_points(points, ax)\n    points = do_smoothing(points, steps)\n\n\n\n\n\nAnswer to 2. Question\nWhy we observe 45° alignment can be answered here: We don’t observe that at all.\nThis peculiar alignment was an artifact of the zooming method which was used in [1]: While we iterate, the polygons get smaller in radius. If we zoom in X and Y direction independently, we will always make it look like being on a diagonal. The alignment is enforced by the zooming and has nothing to do with the smoothing procedure.\nAbove we use a uniform zoom factor (equal axis), which doesn’t break the rotation symmetry and thereby conserves to true alignment of the ellipse."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#prediction-of-final-ellipse",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#prediction-of-final-ellipse",
    "title": "Polygon Smoothing Riddle",
    "section": "Prediction of Final Ellipse",
    "text": "Prediction of Final Ellipse\nThe smoothing procedure is a linear operation which can be formulated in a matrix representation. \\[\\mathbb S \\, \\bf x_k = \\bf x_{k+1}\\]\nTo simplify the analysis, we can recall our QT lectures and do an eigenstate decomposition. Eigenstates (or eigenpolygons) do not change their shape shape under the smoothing operation but are only shrinked and rotated by a complex prefactor (eigenvalue).\n\\[ \\mathbb S \\, \\bf{ x} = \\lambda \\bf{ x} \\]\n\nDominant Eigenstates\nOf course we could do a more strict analysis, but let’s do it physicist free-style way (although Dr. S. wasn’t very happy with that…):\nWe found from numerical calculation (eigenstate analysis) of some polybon point numbers N, that circlular arrangements are eigenstates. They have the largest eigenvalue, i.e. they are the least suppressed/decreased in size from generation to generation, while all the other eigenstates converge faster to zero extend. We have observed this for N=3 and 5, so it must be a very general fact, right?\nTherefore, after a few iterations, circles are the only surviving contribution, everything else decreases much faster in size. So lets phrase the\nHypothesis: Circles are dominant eigenstates under the smoothing operation.\nThere are two independent cicular arrangments, namely\n\neigenstate1 = [np.exp(1j* 2*np.pi/N * k) for k in range(N)]  # clockwise orientation\neigenstate2 = [np.exp(-1j* 2*np.pi/N * k) for k in range(N)] # counter-clockwise orientation\n\nshow_points(eigenstate1, plt.subplot(121))\nshow_points(eigenstate2, plt.subplot(122))\n\n\n\n\nNote their clock/counter-clockwise orientation. Let’s check whether these are really eigenstates:\n\npoints = eigenstate1\n\n# iterate smoothing:\nn = 7\nplt.figure(figsize=[15,3]) \nfor i in range(n):\n    ax = plt.subplot(1,n,i+1)\n    show_points(points, ax)\n    points = do_smoothing(points, 1)\n\n\n\n\nApparently they are. They turn around, but that’s fine as it only is a complex prefactor introducing the turning and shrinking:\n\ndo_smoothing(eigenstate1, 1) / eigenstate1\n\narray([0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j, 0.94272801-0.23236159j,\n       0.94272801-0.23236159j])\n\n\nWorks out as expected. we even get the eigenvalues for free.\n\neigenvalue1 = (do_smoothing(eigenstate1, 1) / eigenstate1)[0]\neigenvalue2 = (do_smoothing(eigenstate2, 1) / eigenstate2)[0]\n\neigenvalue1, eigenvalue2\n\n((0.9427280128266048-0.2323615860218846j),\n (0.9427280128266048+0.2323615860218846j))\n\n\n\n\nDecompose Initial State into Eigenstates\nIn order to find out how much of the eigenstates are included in our random initial state, we project the inital state onto the eigenvectors. This calls for the use of an inner product, which we readily have at hand with the familiar\n\ndef dot(v1, v2):\n    \"\"\"Dot Product between complex vectors\"\"\"\n    return np.dot(v1, np.conj(v2))\n\nLike in the good old QT days with Prof. H., we do first a normalization and check\n\neigenstate1 = eigenstate1 / np.sqrt(dot(eigenstate1, eigenstate1))\neigenstate2 = eigenstate2 / np.sqrt(dot(eigenstate2, eigenstate2))\n\ndot(eigenstate1, eigenstate1), dot(eigenstate2, eigenstate2)\n\n((1+0j), (1+0j))\n\n\nNicely normalized: Check. We can proceed:\nNow, let’s do the projection and get the complex coefficients\n\nc1 = dot(init_points, eigenstate1)\nc2 = dot(init_points, eigenstate2)\n\nc1, c2\n\n((0.5149093832008008-1.950855436819647j),\n (0.07602149507747744+1.113740507931655j))\n\n\nGood, both eigenstates seem to be present in there. What can we do with that?\n\n\nRepresentation as Ellipse\nAn general ellipse is parametrized by \\(\\varphi\\) with \\(a,b\\) being the half axis and \\(\\theta\\) a rotation angle. We define\n\ndef ellipse(a,b, phi, theta): \n    \"\"\"get coordinates of ellipse with half axes a,b rotated with theta, along parameter phi.\"\"\"\n    \n    c, s = a*np.cos(phi), b*np.sin(phi) \n    x = (s, c) # ellipse coordinate vector\n    \n    # rotate it\n    c, s = np.cos(theta), np.sin(theta)\n    R = np.array(((c, -s), (s, c))) # rotation matrix\n    x_rot = np.matmul(R, x)\n    \n    return x_rot[0] + 1j * x_rot[1] # go to complex representation\n\nAs our calculations show (they are still only on our window and wait to be transfered to the appendix in due time, of course), a superposition of both eigenstates result in a ellipse with the following parameters\n\\[ a = \\left|\\frac{|c_1| - |c_2|}{\\sqrt N}\\right|, \\quad b  = \\frac{|c_1| + |c_2|}{\\sqrt N} \\]\nand \\[ \\theta = \\frac{\\arg{c_1} + \\arg{c_2}}{2}\\]\nSo let’s give it a try:\n\nsteps = 300 # how many steps to iterate \n\n# propagete eigenstates through smoothing operation by mulitplying eigenvalue 'steps' times\nc1_it = c1 * np.power(eigenvalue1, steps)\nc2_it = c2 * np.power(eigenvalue2, steps)\n\n# magic, analytic formulas\na = np.abs(np.abs(c1_it) - np.abs(c2_it)) / np.sqrt(N) \nb = (np.abs(c1_it) + np.abs(c2_it)) / np.sqrt(N) \ntheta = (np.angle(c1_it) + np.angle(c2_it)) / 2\n\nellipse_pts = [ellipse(a, b, phi, theta) for phi in np.linspace(0, 2*np.pi, 50)]\n\nax = plt.subplot(111)\nshow_points(ellipse_pts, labels=False, dots=False, ax=ax, linewidth=2)\n\nshow_points(do_smoothing(init_points - np.mean(init_points), steps), labels=False,ax=ax)\n\n\n\n\nThe comparison between the predicted shape and iteratively computed point distribution is rather satisfying.\nAs an encore, we provide the comparison of the prediction based only on the two dominant eigenvalues in comparison to the computed iterated polygon:\n\ndef show_iteration_vs_dominantEigenstates(): \n    points = np.random.standard_normal(N) + np.random.standard_normal(N)*1j\n    points = points - np.mean(points)\n\n    c1 = dot(points, eigenstate1)\n    c2 = dot(points, eigenstate2)\n\n    steps = 3 # steps between plots\n\n    plt.figure(figsize=[10,10])\n\n    for i in range(16):\n        ax = plt.subplot(4, 4, i+1)\n        \n        # show smoothed points\n        show_points(points, ax, labels=False)\n\n        # now, calculate our analytic prediction ellipse for this iteration:\n\n        # propagete eigenstates through smoothing operation by mulitplying eigenvalue 'steps' times\n        c1_it = c1 * np.power(eigenvalue1, i*steps)\n        c2_it = c2 * np.power(eigenvalue2, i*steps)\n\n        a = np.abs(np.abs(c1_it) - np.abs(c2_it)) / np.sqrt(N)\n        b = (np.abs(c1_it) + np.abs(c2_it)) / np.sqrt(N)\n        theta = (np.angle(c1_it) + np.angle(c2_it)) / 2\n        ellipse_pts = [ellipse(a, b, phi, theta) for phi in np.linspace(0, 2*np.pi, 50)]\n\n        show_points(ellipse_pts, labels=False, dots=False, ax=ax, linewidth=2)\n\n        # for next iteration, do smoothing\n        points = do_smoothing(points, steps)\n        \nshow_iteration_vs_dominantEigenstates()\n\n\n\n\nWe see, how the dominant eigenstates start to fully describe the evolution."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#enforcement-of-circular-convergence",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#enforcement-of-circular-convergence",
    "title": "Polygon Smoothing Riddle",
    "section": "Enforcement of Circular Convergence",
    "text": "Enforcement of Circular Convergence\nComparison before and after “Face-lifting”:\n\ninit_points = np.random.standard_normal(N) + np.random.standard_normal(N)*1j\n\ninit_points_facelifted = init_points - dot(init_points, eigenstate1) * eigenstate1 \n# eigenstate1 is hereby fully removed, only eigenstate2 and the other contributions survive\n\nshow_points(init_points, plt.subplot(121))\nshow_points(init_points_facelifted, plt.subplot(122))\n\n\n\n\nLet it roll…\n\nsteps = 4 # steps between plots\n\npoints = init_points_facelifted\n\nplt.figure(figsize=[10,10]) \nfor i in range(16):\n    ax = plt.subplot(4,4,i+1)\n    show_points(points, ax)\n    points = do_smoothing(points, steps)\n\n\n\n\nAmazingly, here you have your ordered circle.\nHomework Exercise: How about a counter-clockwise arrangement? :-)\n\nAnswer to Question 3\nWe can conclude, that the following must be given in order to converge into a circle: Only clockwiseness or only counter-clockwiseness must be included in your start polygon, then it will evolve into a circle. While these terms are not well established in the community yet, we are confident that our work will have its impact here."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#conclusions-and-acknowledgments",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#conclusions-and-acknowledgments",
    "title": "Polygon Smoothing Riddle",
    "section": "Conclusions and Acknowledgments",
    "text": "Conclusions and Acknowledgments\nDear reader, thank you for your appreciated attention!\nWith that we would like to thank for all inspirational inputs from our “physicist” friends!\nYours sincerly, L. and M."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#shift-invariance",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#shift-invariance",
    "title": "Polygon Smoothing Riddle",
    "section": "Shift Invariance",
    "text": "Shift Invariance\nIf we go on step further in analysis, we can readily observe that we not only have a linear operation, but a translation invariant: If we shift the indizes of the point of input state, the smoothing process \\(\\mathbb S\\) will yield the same output as before, but with this output after the index shift. Index shift denoted by \\(\\mathcal R\\) and smoothing operation \\(\\mathbb S\\) commute:\n\\[ \\vec x = (x_1, x_2, ... x_N), \\, \\mathcal R\\,\\vec x = \\vec x' = (x_2, x_3, ... x_N, x_1):  \\quad \\mathcal R (\\mathbb S\\,\\vec x) =  \\mathbb S (\\mathcal R \\,\\vec x) = \\frac 1 2 (x_2+x_3, x_3+x_4, ...)\\]\nA general shift-invariant linear operation on continous functions are given by convolutions \\[ (f \\ast g)(x) \\doteq \\int \\,dy\\, g(y)\\,f(x-y) = h(x), \\quad f(x+\\Delta x) \\ast g(x) = h'(x) = h(x+\\Delta x)\\]\nThe convolution Fourier theorem tells us, that their corresponding Fourier transforms \\(f(x) = \\int\\,dk\\, \\tilde{f}(k)\\, \\exp(ikx)\\), …, are related by a simple multiplication\n\\[ \\tilde{f}(k) \\, \\tilde{g}(k) = \\tilde{h}(k) \\]\nThis is an interesting fact and allows to write a convolution in much simpler terms. Let’s try to apply this to our case."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#discrete-fourier-transforms-dft-theory",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#discrete-fourier-transforms-dft-theory",
    "title": "Polygon Smoothing Riddle",
    "section": "Discrete Fourier Transforms (DFT) Theory",
    "text": "Discrete Fourier Transforms (DFT) Theory\nAs phycisists, we are well experienced with the continous Fourier transform. But we obviously dont have an continous function but discrete points \\((x_1, x_2, ... x_n)\\). Here is a short intro to the discret case. DFT is a very common tool in digital signal processing where the signal is sampled at a fixed frequency…\n\nDiscretness\nLet’s define \\(f(d), d \\in \\mathbb Z\\). This simplifies the Fourier transform to\n\\[f(d) = \\int^{2\\pi}_{0}dk\\, \\tilde{f}(k)\\, \\exp(ikd)\\]\nIntuition: The wavevector spectrum is limited to \\(0...2\\pi\\). Any oscillation faster than “one oscillation per 1 unit” is not needed, as we only evalute \\(f(d)\\) at integer \\(d\\). (This result is known as Nyquist-Shannon theorem and can be gained in a more formal way by multiplying a general \\(f(x)\\) with a Dirac comb which results in the mentioned consequences in wavevector spectrum).\n\n\nFiniteness\nThe above results still assumed an umlimited number of points involved. Without loss of generality, we can define \\(f(d)\\) periodic, such that \\(f(d) = f(d+N)\\) holds. We limit the function to \\(N\\) different values. In general, a periodic function, like the newly defined \\(f(d)\\), can be represented with a discrete Fourier series\n\\[ f(x) = \\sum_{k=-\\inf}^{\\inf}\\, a(k) \\, e^{i\\frac{2\\pi k}{N} x}, \\quad a(k) \\in \\mathbb C .\\]\nIntuition: Only wavevectors with wavelenghts = repetion cycles which are integer fractions of the function cycle length \\(N\\), i.e. cycles which repeat after length \\(N\\), are present.\n\n\nDiscrete and Finite -&gt; DFT\nTaking both results, we ariive at the conclusion, that\n\\[ f(d) = \\sum_{k=0}^{N-1}\\, a(k) \\, e^{i\\frac{2\\pi k}{N} d} \\]\nwhere the coefficients \\(a(k) = \\tilde{f}(k), \\, k \\in \\{0, \\ldots, N-1\\}\\) are the discrete Fourier transform of \\(f(d)\\).\nWe can explicitly calculate for two summands\n\\[ \\sum_{d=0}^{N-1}  e^{i\\frac{2\\pi k}{N} d}  e^{-i\\frac{2\\pi k'}{N} d} = N \\delta_{k-k'} \\]\nand thereby observe the orthogonality of different terms which is well known in the continous case (where a Dirac delta function is used).\n\n\nDiscrete Convolution\nIn analogy to the continous case, a discrete, cylic convolution can be defined by\n\\[ (f \\ast g) (d) = \\sum_{d'=0}^{N-1} g(d') f(d-d') \\]\nwhere we assumed \\(f(d)\\) to be periodic. By explicitly calculating, we find \\[ (f \\ast g) (d)  = \\sum_{d'=0}^{N-1} \\left(\\sum_{k=0}^{N-1}\\, \\tilde g(k) \\, e^{i\\frac{2\\pi k}{N} d'}\\right) \\left(\\sum_{k'=0}^{N-1}\\, \\tilde f(k') \\, e^{i\\frac{2\\pi k'}{N} (d-d')}\\right)\n= \\sum_{k=0}^{N-1} \\sum_{k'=0}^{N-1}\\, \\tilde g(k) \\, \\tilde f(k') \\, \\sum_{d'=0}^{N-1} e^{i\\frac{2\\pi k}{N} d'} e^{i\\frac{2\\pi k'}{N} (d-d')} \\]\nEvaluating the sum over \\(d'\\) and using the orthogonality condition found above, we find a \\(N\\delta_{k-k'}\\) and therefore\n\\[ (f \\ast g) (d)  = N\\,\\sum_{k=0}^{N-1} \\tilde g(k) \\, \\tilde f(k) \\, e^{i\\frac{2\\pi k}{N} d} .\\]\nThis is the equivalent result to the continous case: The convolution is a mutliplication in Fourier space."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#polygon-smoothing-as-discrete-convolution",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#polygon-smoothing-as-discrete-convolution",
    "title": "Polygon Smoothing Riddle",
    "section": "Polygon Smoothing as Discrete Convolution",
    "text": "Polygon Smoothing as Discrete Convolution\nIf we chose\n\\[ f(d)  \\doteq x_{d-1}, \\, d \\in {0, \\ldots, N-1}, \\quad  g(0)= g(1) \\doteq \\frac 1 2, \\, g(d) \\doteq 0, \\, d \\in \\{2,\\ldots, N\\}\\]\nand furthermore impose periodicity with \\(f(d+N) = f(d)\\), equally on \\(g(d)\\), both function are defined over \\(\\mathbb Z\\), but represent \\(N\\) independent complex points. With and the above defined discrete convolution, we find\n\\[ (f \\ast g) (d) = \\sum_{d'=0}^{N-1} g(d') f(d-d') = h(d) = \\frac{x_d+x_{d-1}} 2 \\]\nWe observe that this corresponds to our smoothing/averaging process \\(\\mathbb S\\)! It is a moving averaging operation performed on the set of points.\nThe Fourier convolution theorem tells us, that this linear, shift-invariant operation can be written in this discrete case with the transforms\n\\[ \\tilde{h}(k) = N \\tilde{f}(k)\\,\\tilde{g}(k), \\, k \\in \\{0,N-1\\}\\]\nIf we iterate \\(G\\) times through the smooting, we arrive at the simple result \\[ \\tilde{h}(k) = \\tilde{f}(k)\\,(N\\tilde{g}(k))^{G}\\]\nThis fully determines the evolution. If \\(N|\\tilde g(k)|&lt;1\\), the components at given \\(k\\) are increasingly suppressed. With this, we got all eigenstates of the smoothign operation for free: They are apparatly the Fourier components of different \\(k\\)."
  },
  {
    "objectID": "posts/polygon-smoothing/PolygonSmoothing.html#numeric-illustration",
    "href": "posts/polygon-smoothing/PolygonSmoothing.html#numeric-illustration",
    "title": "Polygon Smoothing Riddle",
    "section": "Numeric Illustration",
    "text": "Numeric Illustration\n\nN = 13\ninitial_points = np.random.standard_normal(N) + np.random.standard_normal(N)*1j\nf = initial_points\n\nLet’s generate to above defined \\(g(d)\\) with\n\ng = np.zeros(N)\ng[[0,1]] = 1/2\nprint(g)\n\n[0.5 0.5 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0. ]\n\n\nLet Python calculate the DFT, as defined above, using FFT functions\n\nf_tilde = np.fft.ifft(f)\ng_tilde = np.fft.ifft(g)\n\nThe smoothing iteration using the convolution theorem is illustrated here togehter with the Fourier transform:\n\nsteps_per_image = 10\nn = 5\n\nplt.figure(figsize=[25,5]) \nfor i in range(n):\n    \n    h_tilde = np.multiply(f_tilde, np.power(N*abs(g_tilde), i*steps_per_image)) # according to convolution fourier theorem, see above\n    h = np.fft.fft(h_tilde)\n\n    ax = plt.subplot(2,n,i+1)\n    ax.set_title(\"$\\\\tilde h(k)$\")\n    ax.bar(range(N),abs(h_tilde))\n    \n    ax = plt.subplot(2,n,i+n+1)\n    ax.set_title(\"$f(d)$\")\n    show_points(h, ax=ax)  \n\n\n\n\nThings seemt to work out\n\nInterpretation\nAs abovious from the multiplication factor \\(\\tilde g(k)\\):\n\nplt.plot(N*abs(g_tilde))\n\n\n\n\noscillations \\(k=0, 1\\) and \\(N-1\\) are dominant. All other are suppressed stronger and damped out in the iteration shown above.\nAs can be seen in the DFT defition, \\(k=0\\) corresponds to a constant, which here represents the center of gravity of the points which does not change through iterations: \\(\\tilde g(0) = 1\\). \\(k=1\\) and \\(N-1\\) are the already known clockwise and counterclockwise circles. If added up in a linear combination, they result in an ellipse.\nAll the other Fourier terms are circles as well, but with winding number \\(W\\) larger than one. Just a few examples:\n\nplt.figure(figsize=[25,4]) \nws = range(-1,5)\nfor i, w in enumerate(ws):\n    ax = plt.subplot(1,len(ws), i+1)\n    ax.set_title(\"W = \" + str(w))\n    \n    a = np.zeros(N)\n    a[w % N] = 1\n    h = np.fft.ifft(a)\n    \n    print(a)\n    show_points(h, ax=ax)\n\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]\n[1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n[0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\n\n\n\nInsofar, we have to correct our answer above: we arrive at pure circles of only winding number \\(W=1\\) or -1 are present, not both. But any higher wining number of any sign (clockwise or counter clockwise) will be damped away anyways.\nGeometrically, this is obvious: the more curved, the stronger diminished are the shapes in the smoothing process.\nWith that, we finally and ultimatley conclude :-)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mu2718’s Blog",
    "section": "",
    "text": "Welcome to my page!\nHave a look at my posts which are about topics I found interesting to dive into. Maybe for you as well? Subscribe to my newsletter for being updated."
  },
  {
    "objectID": "index.html#links",
    "href": "index.html#links",
    "title": "mu2718’s Blog",
    "section": "Links",
    "text": "Links\n\nGPS walkthrough post series\nmu2718 on GitHub"
  },
  {
    "objectID": "index.html#recent-posts",
    "href": "index.html#recent-posts",
    "title": "mu2718’s Blog",
    "section": "Recent Posts",
    "text": "Recent Posts\n\n\n\n\n\n\n\n\n\n\nGPS Walkthrough 1 — Overview\n\n\n\nDec 10, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGPS Walkthrough – A Journey from Radio Wave to Position Fix\n\n\n\nAug 11, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeodesics on Curved Surfaces\n\n\n\nApr 15, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nPolygon Smoothing Riddle\n\n\n\nApr 27, 2020\n\n\n\n\n\n\n\n\nNo matching items\n\n\n  \n\n\n All Posts"
  },
  {
    "objectID": "newsletter.html",
    "href": "newsletter.html",
    "title": "mu2718’s Newsletter",
    "section": "",
    "text": "With the mail newsletter, I will inform you about updates and new blog posts. You can unsubscribe anytime."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Blog Posts",
    "section": "",
    "text": "Subscribe to the newsletter for updates.\n\n\n\n\n\n\n\n\n  \n\n\n\n\nGPS Walkthrough 1 — Overview\n\n\n\n\n\n\n\nGPS\n\n\n\n\nThis post gives an overview of all steps involved in the GPS walkthrough, with all main results but lacking the detailed explanations of later steps.\n\n\n\n\n\n\nDec 10, 2023\n\n\nManuel\n\n\n\n\n\n\n  \n\n\n\n\nGPS Walkthrough – A Journey from Radio Wave to Position Fix\n\n\n\n\n\n\n\nGPS\n\n\nphysics\n\n\n\n\nThis post series will guide you to through the calculation of a position fix from a recorded GPS radio wave signal. In this introduction, the motivation, goals and steps to follow are presented.\n\n\n\n\n\n\nAug 11, 2023\n\n\nManuel\n\n\n\n\n\n\n  \n\n\n\n\nGeodesics on Curved Surfaces\n\n\n\n\n\n\n\nmath\n\n\n\n\nWe investigate geodesics on parametrized curved surfaces which are embedded in 3D space. Visualization and computation is implemented in Python.\n\n\n\n\n\n\nApr 15, 2022\n\n\nManuel\n\n\n\n\n\n\n  \n\n\n\n\nPolygon Smoothing Riddle\n\n\n\n\n\n\n\nmath\n\n\nriddles\n\n\n\n\nWe analyze a geometrical phenomenon appearing in an averaging procedure performed on polygons. Linear algebra and Fourier analysis methods give insights into the mechanism.\n\n\n\n\n\n\nApr 27, 2020\n\n\nManuel and Laura\n\n\n\n\n\n\nNo matching items"
  }
]